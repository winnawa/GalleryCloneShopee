{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport \"./fixPolyfills.js\";\nimport { dep, wrap } from 'optimism';\nimport { ApolloCache } from \"../core/cache.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\nimport { addTypenameToDocument, isReference } from \"../../utilities/index.js\";\nimport { StoreReader } from \"./readFromStore.js\";\nimport { StoreWriter } from \"./writeToStore.js\";\nimport { EntityStore, supportsResultCaching } from \"./entityStore.js\";\nimport { makeVar, forgetCache } from \"./reactiveVars.js\";\nimport { defaultDataIdFromObject, Policies } from \"./policies.js\";\nimport { hasOwn } from \"./helpers.js\";\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  typePolicies: {}\n};\n\nvar InMemoryCache = function (_super) {\n  __extends(InMemoryCache, _super);\n\n  function InMemoryCache(config) {\n    if (config === void 0) {\n      config = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.watches = new Set();\n    _this.typenameDocumentCache = new Map();\n    _this.makeVar = makeVar;\n    _this.txCount = 0;\n    _this.maybeBroadcastWatch = wrap(function (c, fromOptimisticTransaction) {\n      return _this.broadcastWatch.call(_this, c, !!fromOptimisticTransaction);\n    }, {\n      makeCacheKey: function (c) {\n        var store = c.optimistic ? _this.optimisticData : _this.data;\n\n        if (supportsResultCaching(store)) {\n          var optimistic = c.optimistic,\n              rootId = c.rootId,\n              variables = c.variables;\n          return store.makeCacheKey(c.query, c.callback, JSON.stringify({\n            optimistic: optimistic,\n            rootId: rootId,\n            variables: variables\n          }));\n        }\n      }\n    });\n    _this.watchDep = dep();\n    _this.config = __assign(__assign({}, defaultConfig), config);\n    _this.addTypename = !!_this.config.addTypename;\n    _this.policies = new Policies({\n      cache: _this,\n      dataIdFromObject: _this.config.dataIdFromObject,\n      possibleTypes: _this.config.possibleTypes,\n      typePolicies: _this.config.typePolicies\n    });\n    _this.data = new EntityStore.Root({\n      policies: _this.policies,\n      resultCaching: _this.config.resultCaching\n    });\n    _this.optimisticData = _this.data;\n    _this.storeWriter = new StoreWriter(_this, _this.storeReader = new StoreReader({\n      cache: _this,\n      addTypename: _this.addTypename\n    }));\n    return _this;\n  }\n\n  InMemoryCache.prototype.restore = function (data) {\n    if (data) this.data.replace(data);\n    return this;\n  };\n\n  InMemoryCache.prototype.extract = function (optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return (optimistic ? this.optimisticData : this.data).extract();\n  };\n\n  InMemoryCache.prototype.read = function (options) {\n    var _a = options.returnPartialData,\n        returnPartialData = _a === void 0 ? false : _a;\n\n    try {\n      return this.storeReader.diffQueryAgainstStore({\n        store: options.optimistic ? this.optimisticData : this.data,\n        query: options.query,\n        variables: options.variables,\n        rootId: options.rootId,\n        config: this.config,\n        returnPartialData: returnPartialData\n      }).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        return null;\n      }\n\n      throw e;\n    }\n  };\n\n  InMemoryCache.prototype.write = function (options) {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore({\n        store: this.data,\n        query: options.query,\n        result: options.result,\n        dataId: options.dataId,\n        variables: options.variables\n      });\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.modify = function (options) {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      return false;\n    }\n\n    var store = options.optimistic ? this.optimisticData : this.data;\n\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.diff = function (options) {\n    return this.storeReader.diffQueryAgainstStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      query: options.query,\n      variables: options.variables,\n      returnPartialData: options.returnPartialData,\n      config: this.config\n    });\n  };\n\n  InMemoryCache.prototype.watch = function (watch) {\n    var _this = this;\n\n    this.watches.add(watch);\n\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n\n    return function () {\n      if (_this.watches.delete(watch) && !_this.watches.size) {\n        forgetCache(_this);\n      }\n\n      _this.watchDep.dirty(watch);\n\n      _this.maybeBroadcastWatch.forget(watch);\n    };\n  };\n\n  InMemoryCache.prototype.gc = function () {\n    return this.optimisticData.gc();\n  };\n\n  InMemoryCache.prototype.retain = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  };\n\n  InMemoryCache.prototype.release = function (rootId, optimistic) {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  };\n\n  InMemoryCache.prototype.identify = function (object) {\n    return isReference(object) ? object.__ref : this.policies.identify(object)[0];\n  };\n\n  InMemoryCache.prototype.evict = function (options) {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        return false;\n      }\n\n      options = __assign(__assign({}, options), {\n        id: \"ROOT_QUERY\"\n      });\n    }\n\n    try {\n      ++this.txCount;\n      return this.optimisticData.evict(options);\n    } finally {\n      if (! --this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  };\n\n  InMemoryCache.prototype.reset = function () {\n    this.data.clear();\n    this.optimisticData = this.data;\n    this.broadcastWatches();\n    return Promise.resolve();\n  };\n\n  InMemoryCache.prototype.removeOptimistic = function (idToRemove) {\n    var newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  };\n\n  InMemoryCache.prototype.performTransaction = function (transaction, optimisticId) {\n    var _this = this;\n\n    var perform = function (layer) {\n      var _a = _this,\n          data = _a.data,\n          optimisticData = _a.optimisticData;\n      ++_this.txCount;\n\n      if (layer) {\n        _this.data = _this.optimisticData = layer;\n      }\n\n      try {\n        transaction(_this);\n      } finally {\n        --_this.txCount;\n        _this.data = data;\n        _this.optimisticData = optimisticData;\n      }\n    };\n\n    var fromOptimisticTransaction = false;\n\n    if (typeof optimisticId === 'string') {\n      this.optimisticData = this.optimisticData.addLayer(optimisticId, perform);\n      fromOptimisticTransaction = true;\n    } else if (optimisticId === null) {\n      perform(this.data);\n    } else {\n      perform();\n    }\n\n    this.broadcastWatches(fromOptimisticTransaction);\n  };\n\n  InMemoryCache.prototype.transformDocument = function (document) {\n    if (this.addTypename) {\n      var result = this.typenameDocumentCache.get(document);\n\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        this.typenameDocumentCache.set(result, result);\n      }\n\n      return result;\n    }\n\n    return document;\n  };\n\n  InMemoryCache.prototype.broadcastWatches = function (fromOptimisticTransaction) {\n    var _this = this;\n\n    if (!this.txCount) {\n      this.watches.forEach(function (c) {\n        return _this.maybeBroadcastWatch(c, fromOptimisticTransaction);\n      });\n    }\n  };\n\n  InMemoryCache.prototype.broadcastWatch = function (c, fromOptimisticTransaction) {\n    this.watchDep.dirty(c);\n    this.watchDep(c);\n    var diff = this.diff({\n      query: c.query,\n      variables: c.variables,\n      optimistic: c.optimistic\n    });\n\n    if (c.optimistic && fromOptimisticTransaction) {\n      diff.fromOptimisticTransaction = true;\n    }\n\n    c.callback(diff);\n  };\n\n  return InMemoryCache;\n}(ApolloCache);\n\nexport { InMemoryCache };","map":{"version":3,"mappings":"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","names":["dep","wrap","ApolloCache","MissingFieldError","addTypenameToDocument","isReference","StoreReader","StoreWriter","EntityStore","supportsResultCaching","makeVar","forgetCache","defaultDataIdFromObject","Policies","hasOwn","defaultConfig","dataIdFromObject","addTypename","resultCaching","typePolicies","__extends","config","_super","_this","Set","Map","c","fromOptimisticTransaction","broadcastWatch","call","makeCacheKey","store","optimistic","optimisticData","data","rootId","variables","query","callback","JSON","stringify","__assign","policies","cache","possibleTypes","Root","storeWriter","storeReader","InMemoryCache","replace","extract","options","_a","diffQueryAgainstStore","returnPartialData","result","e","txCount","writeToStore","dataId","broadcast","broadcastWatches","id","modify","fields","watch","watches","add","immediate","maybeBroadcastWatch","delete","size","watchDep","dirty","forget","gc","retain","release","object","__ref","identify","evict","clear","Promise","resolve","idToRemove","newOptimisticData","removeLayer","transaction","optimisticId","perform","layer","addLayer","document","typenameDocumentCache","get","set","forEach","diff"],"sourceRoot":"","sources":["../../../src/cache/inmemory/inMemoryCache.ts"],"sourcesContent":["// Make builtins like Map and Set safe to use with non-extensible objects.\nimport './fixPolyfills';\n\nimport { DocumentNode } from 'graphql';\nimport { dep, wrap } from 'optimism';\n\nimport { ApolloCache } from '../core/cache';\nimport { Cache } from '../core/types/Cache';\nimport { MissingFieldError } from '../core/types/common';\nimport {\n  addTypenameToDocument,\n  StoreObject,\n  Reference,\n  isReference,\n} from '../../utilities';\nimport {\n  ApolloReducerConfig,\n  NormalizedCacheObject,\n} from './types';\nimport { StoreReader } from './readFromStore';\nimport { StoreWriter } from './writeToStore';\nimport { EntityStore, supportsResultCaching } from './entityStore';\nimport { makeVar, forgetCache } from './reactiveVars';\nimport {\n  defaultDataIdFromObject,\n  PossibleTypesMap,\n  Policies,\n  TypePolicies,\n} from './policies';\nimport { hasOwn } from './helpers';\n\nexport interface InMemoryCacheConfig extends ApolloReducerConfig {\n  resultCaching?: boolean;\n  possibleTypes?: PossibleTypesMap;\n  typePolicies?: TypePolicies;\n}\n\nconst defaultConfig: InMemoryCacheConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  typePolicies: {},\n};\n\nexport class InMemoryCache extends ApolloCache<NormalizedCacheObject> {\n  private data: EntityStore;\n  private optimisticData: EntityStore;\n\n  protected config: InMemoryCacheConfig;\n  private watches = new Set<Cache.WatchOptions>();\n  private addTypename: boolean;\n\n  private typenameDocumentCache = new Map<DocumentNode, DocumentNode>();\n  private storeReader: StoreReader;\n  private storeWriter: StoreWriter;\n\n  // Dynamically imported code can augment existing typePolicies or\n  // possibleTypes by calling cache.policies.addTypePolicies or\n  // cache.policies.addPossibletypes.\n  public readonly policies: Policies;\n\n  public readonly makeVar = makeVar;\n\n  constructor(config: InMemoryCacheConfig = {}) {\n    super();\n    this.config = { ...defaultConfig, ...config };\n    this.addTypename = !!this.config.addTypename;\n\n    this.policies = new Policies({\n      cache: this,\n      dataIdFromObject: this.config.dataIdFromObject,\n      possibleTypes: this.config.possibleTypes,\n      typePolicies: this.config.typePolicies,\n    });\n\n    // Passing { resultCaching: false } in the InMemoryCache constructor options\n    // will completely disable dependency tracking, which will improve memory\n    // usage but worsen the performance of repeated reads.\n    this.data = new EntityStore.Root({\n      policies: this.policies,\n      resultCaching: this.config.resultCaching,\n    });\n\n    // When no optimistic writes are currently active, cache.optimisticData ===\n    // cache.data, so there are no additional layers on top of the actual data.\n    // When an optimistic update happens, this.optimisticData will become a\n    // linked list of OptimisticCacheLayer objects that terminates with the\n    // original this.data cache object.\n    this.optimisticData = this.data;\n\n    this.storeWriter = new StoreWriter(\n      this,\n      this.storeReader = new StoreReader({\n        cache: this,\n        addTypename: this.addTypename,\n      }),\n    );\n  }\n\n  public restore(data: NormalizedCacheObject): this {\n    if (data) this.data.replace(data);\n    return this;\n  }\n\n  public extract(optimistic: boolean = false): NormalizedCacheObject {\n    return (optimistic ? this.optimisticData : this.data).extract();\n  }\n\n  public read<T>(options: Cache.ReadOptions): T | null {\n    const {\n      // Since read returns data or null, without any additional metadata\n      // about whether/where there might have been missing fields, the\n      // default behavior cannot be returnPartialData = true (like it is\n      // for the diff method), since defaulting to true would violate the\n      // integrity of the T in the return type. However, partial data may\n      // be useful in some cases, so returnPartialData:true may be\n      // specified explicitly.\n      returnPartialData = false,\n    } = options;\n    try {\n      return this.storeReader.diffQueryAgainstStore<T>({\n        store: options.optimistic ? this.optimisticData : this.data,\n        query: options.query,\n        variables: options.variables,\n        rootId: options.rootId,\n        config: this.config,\n        returnPartialData,\n      }).result || null;\n    } catch (e) {\n      if (e instanceof MissingFieldError) {\n        // Swallow MissingFieldError and return null, so callers do not\n        // need to worry about catching \"normal\" exceptions resulting from\n        // incomplete cache data. Unexpected errors will be re-thrown. If\n        // you need more information about which fields were missing, use\n        // cache.diff instead, and examine diffResult.missing.\n        return null;\n      }\n      throw e;\n    }\n  }\n\n  public write(options: Cache.WriteOptions): Reference | undefined {\n    try {\n      ++this.txCount;\n      return this.storeWriter.writeToStore({\n        store: this.data,\n        query: options.query,\n        result: options.result,\n        dataId: options.dataId,\n        variables: options.variables,\n      });\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public modify(options: Cache.ModifyOptions): boolean {\n    if (hasOwn.call(options, \"id\") && !options.id) {\n      // To my knowledge, TypeScript does not currently provide a way to\n      // enforce that an optional property?:type must *not* be undefined\n      // when present. That ability would be useful here, because we want\n      // options.id to default to ROOT_QUERY only when no options.id was\n      // provided. If the caller attempts to pass options.id with a\n      // falsy/undefined value (perhaps because cache.identify failed), we\n      // should not assume the goal was to modify the ROOT_QUERY object.\n      // We could throw, but it seems natural to return false to indicate\n      // that nothing was modified.\n      return false;\n    }\n    const store = options.optimistic // Defaults to false.\n      ? this.optimisticData\n      : this.data;\n    try {\n      ++this.txCount;\n      return store.modify(options.id || \"ROOT_QUERY\", options.fields);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public diff<T>(options: Cache.DiffOptions): Cache.DiffResult<T> {\n    return this.storeReader.diffQueryAgainstStore({\n      store: options.optimistic ? this.optimisticData : this.data,\n      rootId: options.id || \"ROOT_QUERY\",\n      query: options.query,\n      variables: options.variables,\n      returnPartialData: options.returnPartialData,\n      config: this.config,\n    });\n  }\n\n  public watch(watch: Cache.WatchOptions): () => void {\n    this.watches.add(watch);\n    if (watch.immediate) {\n      this.maybeBroadcastWatch(watch);\n    }\n    return () => {\n      // Once we remove the last watch from this.watches, cache.broadcastWatches\n      // no longer does anything, so we preemptively tell the reactive variable\n      // system to exclude this cache from future broadcasts.\n      if (this.watches.delete(watch) && !this.watches.size) {\n        forgetCache(this);\n      }\n      this.watchDep.dirty(watch);\n      // Remove this watch from the LRU cache managed by the\n      // maybeBroadcastWatch OptimisticWrapperFunction, to prevent memory\n      // leaks involving the closure of watch.callback.\n      this.maybeBroadcastWatch.forget(watch);\n    };\n  }\n\n  // Request garbage collection of unreachable normalized entities.\n  public gc() {\n    return this.optimisticData.gc();\n  }\n\n  // Call this method to ensure the given root ID remains in the cache after\n  // garbage collection, along with its transitive child entities. Note that\n  // the cache automatically retains all directly written entities. By default,\n  // the retainment persists after optimistic updates are removed. Pass true\n  // for the optimistic argument if you would prefer for the retainment to be\n  // discarded when the top-most optimistic layer is removed. Returns the\n  // resulting (non-negative) retainment count.\n  public retain(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).retain(rootId);\n  }\n\n  // Call this method to undo the effect of the retain method, above. Once the\n  // retainment count falls to zero, the given ID will no longer be preserved\n  // during garbage collection, though it may still be preserved by other safe\n  // entities that refer to it. Returns the resulting (non-negative) retainment\n  // count, in case that's useful.\n  public release(rootId: string, optimistic?: boolean): number {\n    return (optimistic ? this.optimisticData : this.data).release(rootId);\n  }\n\n  // Returns the canonical ID for a given StoreObject, obeying typePolicies\n  // and keyFields (and dataIdFromObject, if you still use that). At minimum,\n  // the object must contain a __typename and any primary key fields required\n  // to identify entities of that type. If you pass a query result object, be\n  // sure that none of the primary key fields have been renamed by aliasing.\n  // If you pass a Reference object, its __ref ID string will be returned.\n  public identify(object: StoreObject | Reference): string | undefined {\n    return isReference(object) ? object.__ref :\n      this.policies.identify(object)[0];\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    if (!options.id) {\n      if (hasOwn.call(options, \"id\")) {\n        // See comment in modify method about why we return false when\n        // options.id exists but is falsy/undefined.\n        return false;\n      }\n      options = { ...options, id: \"ROOT_QUERY\" };\n    }\n    try {\n      // It's unlikely that the eviction will end up invoking any other\n      // cache update operations while it's running, but {in,de}crementing\n      // this.txCount still seems like a good idea, for uniformity with\n      // the other update methods.\n      ++this.txCount;\n      return this.optimisticData.evict(options);\n    } finally {\n      if (!--this.txCount && options.broadcast !== false) {\n        this.broadcastWatches();\n      }\n    }\n  }\n\n  public reset(): Promise<void> {\n    this.data.clear();\n    this.optimisticData = this.data;\n    this.broadcastWatches();\n    return Promise.resolve();\n  }\n\n  public removeOptimistic(idToRemove: string) {\n    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);\n    if (newOptimisticData !== this.optimisticData) {\n      this.optimisticData = newOptimisticData;\n      this.broadcastWatches();\n    }\n  }\n\n  private txCount = 0;\n\n  public performTransaction(\n    transaction: (cache: InMemoryCache) => any,\n    optimisticId?: string | null,\n  ) {\n    const perform = (layer?: EntityStore) => {\n      const { data, optimisticData } = this;\n      ++this.txCount;\n      if (layer) {\n        this.data = this.optimisticData = layer;\n      }\n      try {\n        transaction(this);\n      } finally {\n        --this.txCount;\n        this.data = data;\n        this.optimisticData = optimisticData;\n      }\n    };\n\n    let fromOptimisticTransaction = false;\n\n    if (typeof optimisticId === 'string') {\n      // Note that there can be multiple layers with the same optimisticId.\n      // When removeOptimistic(id) is called for that id, all matching layers\n      // will be removed, and the remaining layers will be reapplied.\n      this.optimisticData = this.optimisticData.addLayer(optimisticId, perform);\n      fromOptimisticTransaction = true;\n    } else if (optimisticId === null) {\n      // Ensure both this.data and this.optimisticData refer to the root\n      // (non-optimistic) layer of the cache during the transaction. Note\n      // that this.data could be a Layer if we are currently executing an\n      // optimistic transaction function, but otherwise will always be an\n      // EntityStore.Root instance.\n      perform(this.data);\n    } else {\n      // Otherwise, leave this.data and this.optimisticData unchanged and\n      // run the transaction with broadcast batching.\n      perform();\n    }\n\n    // This broadcast does nothing if this.txCount > 0.\n    this.broadcastWatches(fromOptimisticTransaction);\n  }\n\n  public transformDocument(document: DocumentNode): DocumentNode {\n    if (this.addTypename) {\n      let result = this.typenameDocumentCache.get(document);\n      if (!result) {\n        result = addTypenameToDocument(document);\n        this.typenameDocumentCache.set(document, result);\n        // If someone calls transformDocument and then mistakenly passes the\n        // result back into an API that also calls transformDocument, make sure\n        // we don't keep creating new query documents.\n        this.typenameDocumentCache.set(result, result);\n      }\n      return result;\n    }\n    return document;\n  }\n\n  protected broadcastWatches(fromOptimisticTransaction?: boolean) {\n    if (!this.txCount) {\n      this.watches.forEach(c => this.maybeBroadcastWatch(c, fromOptimisticTransaction));\n    }\n  }\n\n  private maybeBroadcastWatch = wrap((\n    c: Cache.WatchOptions,\n    fromOptimisticTransaction?: boolean,\n  ) => {\n    return this.broadcastWatch.call(this, c, !!fromOptimisticTransaction);\n  }, {\n    makeCacheKey: (c: Cache.WatchOptions) => {\n      // Return a cache key (thus enabling result caching) only if we're\n      // currently using a data store that can track cache dependencies.\n      const store = c.optimistic ? this.optimisticData : this.data;\n      if (supportsResultCaching(store)) {\n        const { optimistic, rootId, variables } = c;\n        return store.makeCacheKey(\n          c.query,\n          // Different watches can have the same query, optimistic\n          // status, rootId, and variables, but if their callbacks are\n          // different, the (identical) result needs to be delivered to\n          // each distinct callback. The easiest way to achieve that\n          // separation is to include c.callback in the cache key for\n          // maybeBroadcastWatch calls. See issue #5733.\n          c.callback,\n          JSON.stringify({ optimistic, rootId, variables }),\n        );\n      }\n    }\n  });\n\n  private watchDep = dep<Cache.WatchOptions>();\n\n  // This method is wrapped by maybeBroadcastWatch, which is called by\n  // broadcastWatches, so that we compute and broadcast results only when\n  // the data that would be broadcast might have changed. It would be\n  // simpler to check for changes after recomputing a result but before\n  // broadcasting it, but this wrapping approach allows us to skip both\n  // the recomputation and the broadcast, in most cases.\n  private broadcastWatch(\n    c: Cache.WatchOptions,\n    fromOptimisticTransaction: boolean,\n  ) {\n    // First, invalidate any other maybeBroadcastWatch wrapper functions\n    // currently depending on this Cache.WatchOptions object (including\n    // the one currently calling broadcastWatch), so they will be included\n    // in the next broadcast, even if the result they receive is the same\n    // as the previous result they received. This is important because we\n    // are about to deliver a different result to c.callback, so any\n    // previous results should have a chance to be redelivered.\n    this.watchDep.dirty(c);\n\n    // Next, re-depend on this.watchDep for just this invocation of\n    // maybeBroadcastWatch (this is a no-op if broadcastWatch was not\n    // called by maybeBroadcastWatch). This allows only the most recent\n    // maybeBroadcastWatch invocation for this watcher to remain cached,\n    // enabling re-broadcast of previous results even if they have not\n    // changed since they were previously delivered.\n    this.watchDep(c);\n\n    const diff = this.diff<any>({\n      query: c.query,\n      variables: c.variables,\n      optimistic: c.optimistic,\n    });\n\n    if (c.optimistic && fromOptimisticTransaction) {\n      diff.fromOptimisticTransaction = true;\n    }\n\n    c.callback(diff);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}