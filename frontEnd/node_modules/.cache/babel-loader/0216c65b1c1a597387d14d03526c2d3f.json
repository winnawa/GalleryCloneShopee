{"ast":null,"code":"import { __assign, __rest as __rest_1, __spreadArrays } from \"tslib\";\nimport { __rest } from \"tslib\";\nimport { mergeDeep } from \"../common/mergeDeep.js\";\nexport function concatPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming) {\n      return existing ? __spreadArrays(existing, incoming) : incoming;\n    }\n  };\n}\nexport function offsetLimitPagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    merge: function (existing, incoming, _a) {\n      var args = _a.args;\n      var merged = existing ? existing.slice(0) : [];\n\n      if (args) {\n        var _b = args.offset,\n            offset = _b === void 0 ? 0 : _b;\n\n        for (var i = 0; i < incoming.length; ++i) {\n          merged[offset + i] = incoming[i];\n        }\n      } else {\n        merged.push.apply(merged, incoming);\n      }\n\n      return merged;\n    }\n  };\n}\nexport function relayStylePagination(keyArgs) {\n  if (keyArgs === void 0) {\n    keyArgs = false;\n  }\n\n  return {\n    keyArgs: keyArgs,\n    read: function (existing, _a) {\n      var canRead = _a.canRead,\n          readField = _a.readField;\n      if (!existing) return;\n      var edges = [];\n      var startCursor = \"\";\n      var endCursor = \"\";\n      existing.edges.forEach(function (edge) {\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n\n          if (edge.cursor) {\n            startCursor = startCursor || edge.cursor;\n            endCursor = edge.cursor;\n          }\n        }\n      });\n      return __assign(__assign({}, getExtras(existing)), {\n        edges: edges,\n        pageInfo: __assign(__assign({}, existing.pageInfo), {\n          startCursor: startCursor,\n          endCursor: endCursor\n        })\n      });\n    },\n    merge: function (existing, incoming, _a) {\n      if (existing === void 0) {\n        existing = makeEmptyData();\n      }\n\n      var args = _a.args,\n          isReference = _a.isReference,\n          readField = _a.readField;\n      var incomingEdges = incoming.edges ? incoming.edges.map(function (edge) {\n        if (isReference(edge = __assign({}, edge))) {\n          edge.cursor = readField(\"cursor\", edge);\n        }\n\n        return edge;\n      }) : [];\n\n      if (incoming.pageInfo) {\n        var pageInfo_1 = incoming.pageInfo;\n        var startCursor = pageInfo_1.startCursor,\n            endCursor = pageInfo_1.endCursor;\n        var firstEdge = incomingEdges[0];\n        var lastEdge = incomingEdges[incomingEdges.length - 1];\n\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n\n        var firstCursor = firstEdge && firstEdge.cursor;\n\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor\n            }\n          });\n        }\n\n        var lastCursor = lastEdge && lastEdge.cursor;\n\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor\n            }\n          });\n        }\n      }\n\n      var prefix = existing.edges;\n      var suffix = [];\n\n      if (args && args.after) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.after;\n        });\n\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n        }\n      } else if (args && args.before) {\n        var index = prefix.findIndex(function (edge) {\n          return edge.cursor === args.before;\n        });\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        prefix = [];\n      }\n\n      var edges = __spreadArrays(prefix, incomingEdges, suffix);\n\n      var pageInfo = __assign(__assign({}, incoming.pageInfo), existing.pageInfo);\n\n      if (incoming.pageInfo) {\n        var _b = incoming.pageInfo,\n            hasPreviousPage = _b.hasPreviousPage,\n            hasNextPage = _b.hasNextPage,\n            startCursor = _b.startCursor,\n            endCursor = _b.endCursor,\n            extras = __rest_1(_b, [\"hasPreviousPage\", \"hasNextPage\", \"startCursor\", \"endCursor\"]);\n\n        Object.assign(pageInfo, extras);\n\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return __assign(__assign(__assign({}, getExtras(existing)), getExtras(incoming)), {\n        edges: edges,\n        pageInfo: pageInfo\n      });\n    }\n  };\n}\n\nvar getExtras = function (obj) {\n  return __rest(obj, notExtras);\n};\n\nvar notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData() {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\"\n    }\n  };\n}","map":{"version":3,"mappings":"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","names":["__rest","mergeDeep","concatPagination","keyArgs","merge","existing","incoming","__spreadArrays","offsetLimitPagination","_a","args","merged","slice","_b","i","length","offset","push","apply","relayStylePagination","read","canRead","readField","edges","startCursor","endCursor","forEach","edge","cursor","getExtras","pageInfo","makeEmptyData","isReference","incomingEdges","map","pageInfo_1","firstEdge","lastEdge","firstCursor","lastCursor","prefix","suffix","after","index","findIndex","before","hasPreviousPage","hasNextPage","extras","Object","assign","obj","notExtras"],"sourceRoot":"","sources":["../../../src/utilities/policies/pagination.ts"],"sourcesContent":["import { __rest } from \"tslib\";\n\nimport { FieldPolicy, Reference } from '../../cache';\nimport { mergeDeep } from '../common/mergeDeep';\n\ntype KeyArgs = FieldPolicy<any>[\"keyArgs\"];\n\n// A very basic pagination field policy that always concatenates new\n// results onto the existing array, without examining options.args.\nexport function concatPagination<T = Reference>(\n  keyArgs: KeyArgs = false,\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming) {\n      return existing ? [\n        ...existing,\n        ...incoming,\n      ] : incoming;\n    },\n  };\n}\n\n// A basic field policy that uses options.args.{offset,limit} to splice\n// the incoming data into the existing array. If your arguments are called\n// something different (like args.{start,count}), feel free to copy/paste\n// this implementation and make the appropriate changes.\nexport function offsetLimitPagination<T = Reference>(\n  keyArgs: KeyArgs = false,\n): FieldPolicy<T[]> {\n  return {\n    keyArgs,\n    merge(existing, incoming, { args }) {\n      const merged = existing ? existing.slice(0) : [];\n      if (args) {\n        // Assume an offset of 0 if args.offset omitted.\n        const { offset = 0 } = args;\n        for (let i = 0; i < incoming.length; ++i) {\n          merged[offset + i] = incoming[i];\n        }\n      } else {\n        // It's unusual (probably a mistake) for a paginated field not\n        // to receive any arguments, so you might prefer to throw an\n        // exception here, instead of recovering by appending incoming\n        // onto the existing array.\n        merged.push.apply(merged, incoming);\n      }\n      return merged;\n    },\n  };\n}\n\n// Whether TRelayEdge<TNode> is a normalized Reference or a non-normalized\n// object, it needs a .cursor property where the relayStylePagination\n// merge function can store cursor strings taken from pageInfo. Storing an\n// extra reference.cursor property should be safe, and is easier than\n// attempting to update the cursor field of the normalized StoreObject\n// that the reference refers to, or managing edge wrapper objects\n// (something I attempted in #7023, but abandoned because of #7088).\nexport type TRelayEdge<TNode> = {\n  cursor?: string;\n  node: TNode;\n} | (Reference & { cursor?: string });\n\nexport type TRelayPageInfo = {\n  hasPreviousPage: boolean;\n  hasNextPage: boolean;\n  startCursor: string;\n  endCursor: string;\n};\n\nexport type TExistingRelay<TNode> = Readonly<{\n  edges: TRelayEdge<TNode>[];\n  pageInfo: TRelayPageInfo;\n}>;\n\nexport type TIncomingRelay<TNode> = {\n  edges?: TRelayEdge<TNode>[];\n  pageInfo?: TRelayPageInfo;\n};\n\nexport type RelayFieldPolicy<TNode> = FieldPolicy<\n  TExistingRelay<TNode>,\n  TIncomingRelay<TNode>,\n  TIncomingRelay<TNode>\n>;\n\n// As proof of the flexibility of field policies, this function generates\n// one that handles Relay-style pagination, without Apollo Client knowing\n// anything about connections, edges, cursors, or pageInfo objects.\nexport function relayStylePagination<TNode = Reference>(\n  keyArgs: KeyArgs = false,\n): RelayFieldPolicy<TNode> {\n  return {\n    keyArgs,\n\n    read(existing, { canRead, readField }) {\n      if (!existing) return;\n\n      const edges: TRelayEdge<TNode>[] = [];\n      let startCursor = \"\";\n      let endCursor = \"\";\n      existing.edges.forEach(edge => {\n        // Edges themselves could be Reference objects, so it's important\n        // to use readField to access the edge.edge.node property.\n        if (canRead(readField(\"node\", edge))) {\n          edges.push(edge);\n          if (edge.cursor) {\n            startCursor = startCursor || edge.cursor;\n            endCursor = edge.cursor;\n          }\n        }\n      });\n\n      return {\n        // Some implementations return additional Connection fields, such\n        // as existing.totalCount. These fields are saved by the merge\n        // function, so the read function should also preserve them.\n        ...getExtras(existing),\n        edges,\n        pageInfo: {\n          ...existing.pageInfo,\n          startCursor,\n          endCursor,\n        },\n      };\n    },\n\n    merge(existing = makeEmptyData(), incoming, { args, isReference, readField }) {\n      const incomingEdges = incoming.edges ? incoming.edges.map(edge => {\n        if (isReference(edge = { ...edge })) {\n          // In case edge is a Reference, we read out its cursor field and\n          // store it as an extra property of the Reference object.\n          edge.cursor = readField<string>(\"cursor\", edge);\n        }\n        return edge;\n      }) : [];\n\n      if (incoming.pageInfo) {\n        const { pageInfo } = incoming;\n        const { startCursor, endCursor } = pageInfo;\n        const firstEdge = incomingEdges[0];\n        const lastEdge = incomingEdges[incomingEdges.length - 1];\n        // In case we did not request the cursor field for edges in this\n        // query, we can still infer cursors from pageInfo.\n        if (firstEdge && startCursor) {\n          firstEdge.cursor = startCursor;\n        }\n        if (lastEdge && endCursor) {\n          lastEdge.cursor = endCursor;\n        }\n        // Cursors can also come from edges, so we default\n        // pageInfo.{start,end}Cursor to {first,last}Edge.cursor.\n        const firstCursor = firstEdge && firstEdge.cursor;\n        if (firstCursor && !startCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              startCursor: firstCursor,\n            },\n          });\n        }\n        const lastCursor = lastEdge && lastEdge.cursor;\n        if (lastCursor && !endCursor) {\n          incoming = mergeDeep(incoming, {\n            pageInfo: {\n              endCursor: lastCursor,\n            },\n          });\n        }\n      }\n\n      let prefix = existing.edges;\n      let suffix: typeof prefix = [];\n\n      if (args && args.after) {\n        // This comparison does not need to use readField(\"cursor\", edge),\n        // because we stored the cursor field of any Reference edges as an\n        // extra property of the Reference object.\n        const index = prefix.findIndex(edge => edge.cursor === args.after);\n        if (index >= 0) {\n          prefix = prefix.slice(0, index + 1);\n          // suffix = []; // already true\n        }\n      } else if (args && args.before) {\n        const index = prefix.findIndex(edge => edge.cursor === args.before);\n        suffix = index < 0 ? prefix : prefix.slice(index);\n        prefix = [];\n      } else if (incoming.edges) {\n        // If we have neither args.after nor args.before, the incoming\n        // edges cannot be spliced into the existing edges, so they must\n        // replace the existing edges. See #6592 for a motivating example.\n        prefix = [];\n      }\n\n      const edges = [\n        ...prefix,\n        ...incomingEdges,\n        ...suffix,\n      ];\n\n      const pageInfo: TRelayPageInfo = {\n        // The ordering of these two ...spreads may be surprising, but it\n        // makes sense because we want to combine PageInfo properties with a\n        // preference for existing values, *unless* the existing values are\n        // overridden by the logic below, which is permitted only when the\n        // incoming page falls at the beginning or end of the data.\n        ...incoming.pageInfo,\n        ...existing.pageInfo,\n      };\n\n      if (incoming.pageInfo) {\n        const {\n          hasPreviousPage, hasNextPage,\n          startCursor, endCursor,\n          ...extras\n        } = incoming.pageInfo;\n\n        // If incoming.pageInfo had any extra non-standard properties,\n        // assume they should take precedence over any existing properties\n        // of the same name, regardless of where this page falls with\n        // respect to the existing data.\n        Object.assign(pageInfo, extras);\n\n        // Keep existing.pageInfo.has{Previous,Next}Page unless the\n        // placement of the incoming edges means incoming.hasPreviousPage\n        // or incoming.hasNextPage should become the new values for those\n        // properties in existing.pageInfo. Note that these updates are\n        // only permitted when the beginning or end of the incoming page\n        // coincides with the beginning or end of the existing data, as\n        // determined using prefix.length and suffix.length.\n        if (!prefix.length) {\n          if (void 0 !== hasPreviousPage) pageInfo.hasPreviousPage = hasPreviousPage;\n          if (void 0 !== startCursor) pageInfo.startCursor = startCursor;\n        }\n        if (!suffix.length) {\n          if (void 0 !== hasNextPage) pageInfo.hasNextPage = hasNextPage;\n          if (void 0 !== endCursor) pageInfo.endCursor = endCursor;\n        }\n      }\n\n      return {\n        ...getExtras(existing),\n        ...getExtras(incoming),\n        edges,\n        pageInfo,\n      };\n    },\n  };\n}\n\n// Returns any unrecognized properties of the given object.\nconst getExtras = (obj: Record<string, any>) => __rest(obj, notExtras);\nconst notExtras = [\"edges\", \"pageInfo\"];\n\nfunction makeEmptyData(): TExistingRelay<any> {\n  return {\n    edges: [],\n    pageInfo: {\n      hasPreviousPage: false,\n      hasNextPage: true,\n      startCursor: \"\",\n      endCursor: \"\",\n    },\n  };\n}\n"]},"metadata":{},"sourceType":"module"}