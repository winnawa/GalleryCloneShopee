{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { wrap } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { isField, resultKeyNameFromField, isReference, makeReference, createFragmentMap, shouldInclude, addTypenameToDocument, getDefaultValues, getFragmentDefinitions, getMainDefinition, getQueryDefinition, maybeDeepFreeze, mergeDeepArray, getFragmentFromSelection } from \"../../utilities/index.js\";\nimport { supportsResultCaching } from \"./entityStore.js\";\nimport { getTypenameFromStoreObject } from \"./helpers.js\";\nimport { MissingFieldError } from \"../core/types/common.js\";\n;\n\nfunction missingFromInvariant(err, context) {\n  return new MissingFieldError(err.message, context.path.slice(), context.query, context.clientOnly, context.variables);\n}\n\nvar StoreReader = function () {\n  function StoreReader(config) {\n    var _this = this;\n\n    this.config = config;\n    this.executeSelectionSet = wrap(function (options) {\n      return _this.execSelectionSetImpl(options);\n    }, {\n      keyArgs: function (options) {\n        return [options.selectionSet, options.objectOrReference, options.context];\n      },\n      makeCacheKey: function (selectionSet, parent, context) {\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString);\n        }\n      }\n    });\n    this.knownResults = new WeakMap();\n    this.executeSubSelectedArray = wrap(function (options) {\n      return _this.execSubSelectedArrayImpl(options);\n    }, {\n      makeCacheKey: function (_a) {\n        var field = _a.field,\n            array = _a.array,\n            context = _a.context;\n\n        if (supportsResultCaching(context.store)) {\n          return context.store.makeCacheKey(field, array, context.varString);\n        }\n      }\n    });\n    this.config = __assign({\n      addTypename: true\n    }, config);\n  }\n\n  StoreReader.prototype.diffQueryAgainstStore = function (_a) {\n    var store = _a.store,\n        query = _a.query,\n        _b = _a.rootId,\n        rootId = _b === void 0 ? 'ROOT_QUERY' : _b,\n        variables = _a.variables,\n        _c = _a.returnPartialData,\n        returnPartialData = _c === void 0 ? true : _c;\n    var policies = this.config.cache.policies;\n    variables = __assign(__assign({}, getDefaultValues(getQueryDefinition(query))), variables);\n    var execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: makeReference(rootId),\n      context: {\n        store: store,\n        query: query,\n        policies: policies,\n        variables: variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n        clientOnly: false\n      }\n    });\n    var hasMissingFields = execResult.missing && execResult.missing.length > 0;\n\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing[0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields\n    };\n  };\n\n  StoreReader.prototype.isFresh = function (result, parent, selectionSet, context) {\n    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {\n      var latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  StoreReader.prototype.execSelectionSetImpl = function (_a) {\n    var _this = this;\n\n    var selectionSet = _a.selectionSet,\n        objectOrReference = _a.objectOrReference,\n        context = _a.context;\n\n    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: {},\n        missing: [missingFromInvariant(process.env.NODE_ENV === \"production\" ? new InvariantError(4) : new InvariantError(\"Dangling reference to missing \" + objectOrReference.__ref + \" object\"), context)]\n      };\n    }\n\n    var variables = context.variables,\n        policies = context.policies,\n        store = context.store;\n    var objectsToMerge = [];\n    var finalResult = {\n      result: null\n    };\n    var typename = store.getFieldValue(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename && typeof typename === \"string\" && !policies.rootIdsByTypename[typename]) {\n      objectsToMerge.push({\n        __typename: typename\n      });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing(result) {\n      var _a;\n\n      if (result.missing) (_a = getMissing()).push.apply(_a, result.missing);\n      return result.result;\n    }\n\n    var workSet = new Set(selectionSet.selections);\n    workSet.forEach(function (selection) {\n      var _a;\n\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        var fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference\n        }, context);\n        var resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n        var wasClientOnly = context.clientOnly;\n        context.clientOnly = wasClientOnly || !!(selection.directives && selection.directives.some(function (d) {\n          return d.name.value === \"client\";\n        }));\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(missingFromInvariant(process.env.NODE_ENV === \"production\" ? new InvariantError(5) : new InvariantError(\"Can't find field '\" + selection.name.value + \"' on \" + (isReference(objectOrReference) ? objectOrReference.__ref + \" object\" : \"object \" + JSON.stringify(objectOrReference, null, 2))), context));\n          }\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(_this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            context: context\n          }));\n        } else if (!selection.selectionSet) {\n          if (process.env.NODE_ENV !== 'production') {\n            assertSelectionSetForIdValue(context.store, selection, fieldValue);\n            maybeDeepFreeze(fieldValue);\n          }\n        } else if (fieldValue != null) {\n          fieldValue = handleMissing(_this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue,\n            context: context\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push((_a = {}, _a[resultName] = fieldValue, _a));\n        }\n\n        context.clientOnly = wasClientOnly;\n        invariant(context.path.pop() === resultName);\n      } else {\n        var fragment = getFragmentFromSelection(selection, context.fragmentMap);\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    this.knownResults.set(finalResult.result, selectionSet);\n    return finalResult;\n  };\n\n  StoreReader.prototype.execSubSelectedArrayImpl = function (_a) {\n    var _this = this;\n\n    var field = _a.field,\n        array = _a.array,\n        context = _a.context;\n    var missing;\n\n    function handleMissing(childResult, i) {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push.apply(missing, childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map(function (item, i) {\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      if (Array.isArray(item)) {\n        return handleMissing(_this.executeSubSelectedArray({\n          field: field,\n          array: item,\n          context: context\n        }), i);\n      }\n\n      if (field.selectionSet) {\n        return handleMissing(_this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          context: context\n        }), i);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n      return item;\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return {\n      result: array,\n      missing: missing\n    };\n  };\n\n  return StoreReader;\n}();\n\nexport { StoreReader };\n\nfunction assertSelectionSetForIdValue(store, field, fieldValue) {\n  if (!field.selectionSet) {\n    var workSet_1 = new Set([fieldValue]);\n    workSet_1.forEach(function (value) {\n      if (value && typeof value === \"object\") {\n        process.env.NODE_ENV === \"production\" ? invariant(!isReference(value), 6) : invariant(!isReference(value), \"Missing selection set for object of type \" + getTypenameFromStoreObject(store, value) + \" returned for query field \" + field.name.value);\n        Object.values(value).forEach(workSet_1.add, workSet_1);\n      }\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["wrap","invariant","InvariantError","isField","resultKeyNameFromField","isReference","makeReference","createFragmentMap","shouldInclude","addTypenameToDocument","getDefaultValues","getFragmentDefinitions","getMainDefinition","getQueryDefinition","maybeDeepFreeze","mergeDeepArray","getFragmentFromSelection","supportsResultCaching","getTypenameFromStoreObject","MissingFieldError","missingFromInvariant","err","context","message","path","slice","query","clientOnly","variables","config","execSelectionSetImpl","options","keyArgs","selectionSet","objectOrReference","makeCacheKey","parent","store","__ref","varString","WeakMap","_this","execSubSelectedArrayImpl","_a","field","array","__assign","addTypename","StoreReader","_b","rootId","_c","returnPartialData","policies","cache","execResult","executeSelectionSet","JSON","stringify","fragmentMap","hasMissingFields","missing","length","result","complete","knownResults","get","latest","peek","rootTypenamesById","has","process","NODE_ENV","objectsToMerge","finalResult","typename","getFieldValue","rootIdsByTypename","push","__typename","getMissing","handleMissing","apply","workSet","Set","selections","forEach","selection","fieldValue","readField","fieldName","name","value","from","resultName","wasClientOnly","directives","some","added","Array","isArray","executeSubSelectedArray","env","assertSelectionSetForIdValue","pop","fragment","fragmentMatches","add","Object","freeze","set","childResult","i","filter","canRead","map","item","workSet_1","values"],"sourceRoot":"","sources":["../../../src/cache/inmemory/readFromStore.ts"],"sourcesContent":["import {\n  DocumentNode,\n  FieldNode,\n  SelectionSetNode,\n} from 'graphql';\nimport { wrap, OptimisticWrapperFunction } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  isField,\n  resultKeyNameFromField,\n  Reference,\n  isReference,\n  makeReference,\n  StoreObject,\n  createFragmentMap,\n  FragmentMap,\n  shouldInclude,\n  addTypenameToDocument,\n  getDefaultValues,\n  getFragmentDefinitions,\n  getMainDefinition,\n  getQueryDefinition,\n  maybeDeepFreeze,\n  mergeDeepArray,\n  getFragmentFromSelection,\n} from '../../utilities';\nimport { Cache } from '../core/types/Cache';\nimport {\n  DiffQueryAgainstStoreOptions,\n  NormalizedCache,\n  ReadMergeModifyContext,\n} from './types';\nimport { supportsResultCaching } from './entityStore';\nimport { getTypenameFromStoreObject } from './helpers';\nimport { Policies } from './policies';\nimport { InMemoryCache } from './inMemoryCache';\nimport { MissingFieldError } from '../core/types/common';\n\nexport type VariableMap = { [name: string]: any };\n\ninterface ReadContext extends ReadMergeModifyContext {\n  query: DocumentNode;\n  policies: Policies;\n  fragmentMap: FragmentMap;\n  path: (string | number)[];\n  clientOnly: boolean;\n};\n\nexport type ExecResult<R = any> = {\n  result: R;\n  missing?: MissingFieldError[];\n};\n\nfunction missingFromInvariant(\n  err: InvariantError,\n  context: ReadContext,\n) {\n  return new MissingFieldError(\n    err.message,\n    context.path.slice(),\n    context.query,\n    context.clientOnly,\n    context.variables,\n  );\n}\n\ntype ExecSelectionSetOptions = {\n  selectionSet: SelectionSetNode;\n  objectOrReference: StoreObject | Reference;\n  context: ReadContext;\n};\n\ntype ExecSubSelectedArrayOptions = {\n  field: FieldNode;\n  array: any[];\n  context: ReadContext;\n};\n\nexport interface StoreReaderConfig {\n  cache: InMemoryCache,\n  addTypename?: boolean;\n}\n\nexport class StoreReader {\n  constructor(private config: StoreReaderConfig) {\n    this.config = { addTypename: true, ...config };\n  }\n\n  /**\n   * Given a store and a query, return as much of the result as possible and\n   * identify if any data was missing from the store.\n   * @param  {DocumentNode} query A parsed GraphQL query document\n   * @param  {Store} store The Apollo Client store object\n   * @return {result: Object, complete: [boolean]}\n   */\n  public diffQueryAgainstStore<T>({\n    store,\n    query,\n    rootId = 'ROOT_QUERY',\n    variables,\n    returnPartialData = true,\n  }: DiffQueryAgainstStoreOptions): Cache.DiffResult<T> {\n    const policies = this.config.cache.policies;\n\n    variables = {\n      ...getDefaultValues(getQueryDefinition(query)),\n      ...variables,\n    };\n\n    const execResult = this.executeSelectionSet({\n      selectionSet: getMainDefinition(query).selectionSet,\n      objectOrReference: makeReference(rootId),\n      context: {\n        store,\n        query,\n        policies,\n        variables,\n        varString: JSON.stringify(variables),\n        fragmentMap: createFragmentMap(getFragmentDefinitions(query)),\n        path: [],\n        clientOnly: false,\n      },\n    });\n\n    const hasMissingFields =\n      execResult.missing && execResult.missing.length > 0;\n    if (hasMissingFields && !returnPartialData) {\n      throw execResult.missing![0];\n    }\n\n    return {\n      result: execResult.result,\n      missing: execResult.missing,\n      complete: !hasMissingFields,\n    };\n  }\n\n  public isFresh(\n    result: Record<string, any>,\n    parent: StoreObject | Reference,\n    selectionSet: SelectionSetNode,\n    context: ReadMergeModifyContext,\n  ): boolean {\n    if (supportsResultCaching(context.store) &&\n        this.knownResults.get(result) === selectionSet) {\n      const latest = this.executeSelectionSet.peek(selectionSet, parent, context);\n      if (latest && result === latest.result) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Cached version of execSelectionSetImpl.\n  private executeSelectionSet: OptimisticWrapperFunction<\n    [ExecSelectionSetOptions], // Actual arguments tuple type.\n    ExecResult, // Actual return type.\n    // Arguments type after keyArgs translation.\n    [SelectionSetNode, StoreObject | Reference, ReadMergeModifyContext]\n  > = wrap(options => this.execSelectionSetImpl(options), {\n    keyArgs(options) {\n      return [\n        options.selectionSet,\n        options.objectOrReference,\n        options.context,\n      ];\n    },\n    // Note that the parameters of makeCacheKey are determined by the\n    // array returned by keyArgs.\n    makeCacheKey(selectionSet, parent, context) {\n      if (supportsResultCaching(context.store)) {\n        return context.store.makeCacheKey(\n          selectionSet,\n          isReference(parent) ? parent.__ref : parent,\n          context.varString,\n        );\n      }\n    }\n  });\n\n  // Uncached version of executeSelectionSet.\n  private execSelectionSetImpl({\n    selectionSet,\n    objectOrReference,\n    context,\n  }: ExecSelectionSetOptions): ExecResult {\n    if (isReference(objectOrReference) &&\n        !context.policies.rootTypenamesById[objectOrReference.__ref] &&\n        !context.store.has(objectOrReference.__ref)) {\n      return {\n        result: {},\n        missing: [missingFromInvariant(\n          new InvariantError(\n            `Dangling reference to missing ${objectOrReference.__ref} object`\n          ),\n          context,\n        )],\n      };\n    }\n\n    const { variables, policies, store } = context;\n    const objectsToMerge: { [key: string]: any }[] = [];\n    const finalResult: ExecResult = { result: null };\n    const typename = store.getFieldValue<string>(objectOrReference, \"__typename\");\n\n    if (this.config.addTypename &&\n        typeof typename === \"string\" &&\n        !policies.rootIdsByTypename[typename]) {\n      // Ensure we always include a default value for the __typename\n      // field, if we have one, and this.config.addTypename is true. Note\n      // that this field can be overridden by other merged objects.\n      objectsToMerge.push({ __typename: typename });\n    }\n\n    function getMissing() {\n      return finalResult.missing || (finalResult.missing = []);\n    }\n\n    function handleMissing<T>(result: ExecResult<T>): T {\n      if (result.missing) getMissing().push(...result.missing);\n      return result.result;\n    }\n\n    const workSet = new Set(selectionSet.selections);\n\n    workSet.forEach(selection => {\n      // Omit fields with directives @skip(if: <truthy value>) or\n      // @include(if: <falsy value>).\n      if (!shouldInclude(selection, variables)) return;\n\n      if (isField(selection)) {\n        let fieldValue = policies.readField({\n          fieldName: selection.name.value,\n          field: selection,\n          variables: context.variables,\n          from: objectOrReference,\n        }, context);\n\n        const resultName = resultKeyNameFromField(selection);\n        context.path.push(resultName);\n\n        // If this field has an @client directive, then the field and\n        // everything beneath it is client-only, meaning it will never be\n        // sent to the server.\n        const wasClientOnly = context.clientOnly;\n        // Once we enter a client-only subtree of the query, we can avoid\n        // repeatedly checking selection.directives.\n        context.clientOnly = wasClientOnly || !!(\n          // We don't use the hasDirectives helper here, because it looks\n          // for directives anywhere inside the AST node, whereas we only\n          // care about directives directly attached to this field.\n          selection.directives &&\n          selection.directives.some(d => d.name.value === \"client\")\n        );\n\n        if (fieldValue === void 0) {\n          if (!addTypenameToDocument.added(selection)) {\n            getMissing().push(\n              missingFromInvariant(\n                new InvariantError(`Can't find field '${\n                  selection.name.value\n                }' on ${\n                  isReference(objectOrReference)\n                    ? objectOrReference.__ref + \" object\"\n                    : \"object \" + JSON.stringify(objectOrReference, null, 2)\n                }`),\n                context,\n              ),\n            );\n          }\n\n        } else if (Array.isArray(fieldValue)) {\n          fieldValue = handleMissing(this.executeSubSelectedArray({\n            field: selection,\n            array: fieldValue,\n            context,\n          }));\n\n        } else if (!selection.selectionSet) {\n          // If the field does not have a selection set, then we handle it\n          // as a scalar value. However, that value should not contain any\n          // Reference objects, and should be frozen in development, if it\n          // happens to be an object that is mutable.\n          if (process.env.NODE_ENV !== 'production') {\n            assertSelectionSetForIdValue(\n              context.store,\n              selection,\n              fieldValue,\n            );\n            maybeDeepFreeze(fieldValue);\n          }\n\n        } else if (fieldValue != null) {\n          // In this case, because we know the field has a selection set,\n          // it must be trying to query a GraphQLObjectType, which is why\n          // fieldValue must be != null.\n          fieldValue = handleMissing(this.executeSelectionSet({\n            selectionSet: selection.selectionSet,\n            objectOrReference: fieldValue as StoreObject | Reference,\n            context,\n          }));\n        }\n\n        if (fieldValue !== void 0) {\n          objectsToMerge.push({ [resultName]: fieldValue });\n        }\n\n        context.clientOnly = wasClientOnly;\n\n        invariant(context.path.pop() === resultName);\n\n      } else {\n        const fragment = getFragmentFromSelection(\n          selection,\n          context.fragmentMap,\n        );\n\n        if (fragment && policies.fragmentMatches(fragment, typename)) {\n          fragment.selectionSet.selections.forEach(workSet.add, workSet);\n        }\n      }\n    });\n\n    // Perform a single merge at the end so that we can avoid making more\n    // defensive shallow copies than necessary.\n    finalResult.result = mergeDeepArray(objectsToMerge);\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(finalResult.result);\n    }\n\n    // Store this result with its selection set so that we can quickly\n    // recognize it again in the StoreReader#isFresh method.\n    this.knownResults.set(finalResult.result, selectionSet);\n\n    return finalResult;\n  }\n\n  private knownResults = new WeakMap<Record<string, any>, SelectionSetNode>();\n\n  // Cached version of execSubSelectedArrayImpl.\n  private executeSubSelectedArray = wrap((options: ExecSubSelectedArrayOptions) => {\n    return this.execSubSelectedArrayImpl(options);\n  }, {\n    makeCacheKey({ field, array, context }) {\n      if (supportsResultCaching(context.store)) {\n        return context.store.makeCacheKey(\n          field,\n          array,\n          context.varString,\n        );\n      }\n    }\n  });\n\n  // Uncached version of executeSubSelectedArray.\n  private execSubSelectedArrayImpl({\n    field,\n    array,\n    context,\n  }: ExecSubSelectedArrayOptions): ExecResult {\n    let missing: MissingFieldError[] | undefined;\n\n    function handleMissing<T>(childResult: ExecResult<T>, i: number): T {\n      if (childResult.missing) {\n        missing = missing || [];\n        missing.push(...childResult.missing);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return childResult.result;\n    }\n\n    if (field.selectionSet) {\n      array = array.filter(context.store.canRead);\n    }\n\n    array = array.map((item, i) => {\n      // null value in array\n      if (item === null) {\n        return null;\n      }\n\n      context.path.push(i);\n\n      // This is a nested array, recurse\n      if (Array.isArray(item)) {\n        return handleMissing(this.executeSubSelectedArray({\n          field,\n          array: item,\n          context,\n        }), i);\n      }\n\n      // This is an object, run the selection set on it\n      if (field.selectionSet) {\n        return handleMissing(this.executeSelectionSet({\n          selectionSet: field.selectionSet,\n          objectOrReference: item,\n          context,\n        }), i);\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        assertSelectionSetForIdValue(context.store, field, item);\n      }\n\n      invariant(context.path.pop() === i);\n\n      return item;\n    });\n\n    if (process.env.NODE_ENV !== 'production') {\n      Object.freeze(array);\n    }\n\n    return { result: array, missing };\n  }\n}\n\nfunction assertSelectionSetForIdValue(\n  store: NormalizedCache,\n  field: FieldNode,\n  fieldValue: any,\n) {\n  if (!field.selectionSet) {\n    const workSet = new Set([fieldValue]);\n    workSet.forEach(value => {\n      if (value && typeof value === \"object\") {\n        invariant(\n          !isReference(value),\n          `Missing selection set for object of type ${\n            getTypenameFromStoreObject(store, value)\n          } returned for query field ${field.name.value}`,\n        );\n        Object.values(value).forEach(workSet.add, workSet);\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}