{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport { dep, KeyTrie } from 'optimism';\nimport { equal } from '@wry/equality';\nimport { isReference, makeReference, DeepMerger, maybeDeepFreeze, canUseWeakMap } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName } from \"./helpers.js\";\nvar DELETE = Object.create(null);\n\nvar delModifier = function () {\n  return DELETE;\n};\n\nvar INVALIDATE = Object.create(null);\n\nvar EntityStore = function () {\n  function EntityStore(policies, group) {\n    var _this = this;\n\n    this.policies = policies;\n    this.group = group;\n    this.data = Object.create(null);\n    this.rootIds = Object.create(null);\n    this.refs = Object.create(null);\n\n    this.getFieldValue = function (objectOrReference, storeFieldName) {\n      return maybeDeepFreeze(isReference(objectOrReference) ? _this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]);\n    };\n\n    this.canRead = function (objOrRef) {\n      return isReference(objOrRef) ? _this.has(objOrRef.__ref) : typeof objOrRef === \"object\";\n    };\n\n    this.toReference = function (objOrIdOrRef, mergeIntoStore) {\n      if (typeof objOrIdOrRef === \"string\") {\n        return makeReference(objOrIdOrRef);\n      }\n\n      if (isReference(objOrIdOrRef)) {\n        return objOrIdOrRef;\n      }\n\n      var id = _this.policies.identify(objOrIdOrRef)[0];\n\n      if (id) {\n        var ref = makeReference(id);\n\n        if (mergeIntoStore) {\n          _this.merge(id, objOrIdOrRef);\n        }\n\n        return ref;\n      }\n    };\n  }\n\n  EntityStore.prototype.toObject = function () {\n    return __assign({}, this.data);\n  };\n\n  EntityStore.prototype.has = function (dataId) {\n    return this.lookup(dataId, true) !== void 0;\n  };\n\n  EntityStore.prototype.get = function (dataId, fieldName) {\n    this.group.depend(dataId, fieldName);\n\n    if (hasOwn.call(this.data, dataId)) {\n      var storeObject = this.data[dataId];\n\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n\n    if (fieldName === \"__typename\" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  };\n\n  EntityStore.prototype.lookup = function (dataId, dependOnExistence) {\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  };\n\n  EntityStore.prototype.merge = function (dataId, incoming) {\n    var _this = this;\n\n    var existing = this.lookup(dataId);\n    var merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n    this.data[dataId] = merged;\n\n    if (merged !== existing) {\n      delete this.refs[dataId];\n\n      if (this.group.caching) {\n        var fieldsToDirty_1 = Object.create(null);\n        if (!existing) fieldsToDirty_1.__exists = 1;\n        Object.keys(incoming).forEach(function (storeFieldName) {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            fieldsToDirty_1[storeFieldName] = 1;\n            var fieldName = fieldNameFromStoreName(storeFieldName);\n\n            if (fieldName !== storeFieldName && !_this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty_1[fieldName] = 1;\n            }\n\n            if (merged[storeFieldName] === void 0 && !(_this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n        Object.keys(fieldsToDirty_1).forEach(function (fieldName) {\n          return _this.group.dirty(dataId, fieldName);\n        });\n      }\n    }\n  };\n\n  EntityStore.prototype.modify = function (dataId, fields) {\n    var _this = this;\n\n    var storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      var changedFields_1 = Object.create(null);\n      var needToMerge_1 = false;\n      var allDeleted_1 = true;\n      var sharedDetails_1 = {\n        DELETE: DELETE,\n        INVALIDATE: INVALIDATE,\n        isReference: isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: function (fieldNameOrOptions, from) {\n          return _this.policies.readField(typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId)\n          } : fieldNameOrOptions, {\n            store: _this\n          });\n        }\n      };\n      Object.keys(storeObject).forEach(function (storeFieldName) {\n        var fieldName = fieldNameFromStoreName(storeFieldName);\n        var fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        var modify = typeof fields === \"function\" ? fields : fields[storeFieldName] || fields[fieldName];\n\n        if (modify) {\n          var newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), __assign(__assign({}, sharedDetails_1), {\n            fieldName: fieldName,\n            storeFieldName: storeFieldName,\n            storage: _this.getStorage(dataId, storeFieldName)\n          }));\n\n          if (newValue === INVALIDATE) {\n            _this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n\n            if (newValue !== fieldValue) {\n              changedFields_1[storeFieldName] = newValue;\n              needToMerge_1 = true;\n              fieldValue = newValue;\n            }\n          }\n        }\n\n        if (fieldValue !== void 0) {\n          allDeleted_1 = false;\n        }\n      });\n\n      if (needToMerge_1) {\n        this.merge(dataId, changedFields_1);\n\n        if (allDeleted_1) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  EntityStore.prototype.delete = function (dataId, fieldName, args) {\n    var _a;\n\n    var storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      var typename = this.getFieldValue(storeObject, \"__typename\");\n      var storeFieldName = fieldName && args ? this.policies.getStoreFieldName({\n        typename: typename,\n        fieldName: fieldName,\n        args: args\n      }) : fieldName;\n      return this.modify(dataId, storeFieldName ? (_a = {}, _a[storeFieldName] = delModifier, _a) : delModifier);\n    }\n\n    return false;\n  };\n\n  EntityStore.prototype.evict = function (options) {\n    var evicted = false;\n\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n\n      if (this instanceof Layer) {\n        evicted = this.parent.evict(options) || evicted;\n      }\n\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n\n    return evicted;\n  };\n\n  EntityStore.prototype.clear = function () {\n    this.replace(null);\n  };\n\n  EntityStore.prototype.extract = function () {\n    var _this = this;\n\n    var obj = this.toObject();\n    var extraRootIds = [];\n    this.getRootIdSet().forEach(function (id) {\n      if (!hasOwn.call(_this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n\n    if (extraRootIds.length) {\n      obj.__META = {\n        extraRootIds: extraRootIds.sort()\n      };\n    }\n\n    return obj;\n  };\n\n  EntityStore.prototype.replace = function (newData) {\n    var _this = this;\n\n    Object.keys(this.data).forEach(function (dataId) {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        _this.delete(dataId);\n      }\n    });\n\n    if (newData) {\n      var __META = newData.__META,\n          rest_1 = __rest(newData, [\"__META\"]);\n\n      Object.keys(rest_1).forEach(function (dataId) {\n        _this.merge(dataId, rest_1[dataId]);\n      });\n\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  };\n\n  EntityStore.prototype.retain = function (rootId) {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  };\n\n  EntityStore.prototype.release = function (rootId) {\n    if (this.rootIds[rootId] > 0) {\n      var count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n\n    return 0;\n  };\n\n  EntityStore.prototype.getRootIdSet = function (ids) {\n    if (ids === void 0) {\n      ids = new Set();\n    }\n\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n\n    return ids;\n  };\n\n  EntityStore.prototype.gc = function () {\n    var _this = this;\n\n    var ids = this.getRootIdSet();\n    var snapshot = this.toObject();\n    ids.forEach(function (id) {\n      if (hasOwn.call(snapshot, id)) {\n        Object.keys(_this.findChildRefIds(id)).forEach(ids.add, ids);\n        delete snapshot[id];\n      }\n    });\n    var idsToRemove = Object.keys(snapshot);\n\n    if (idsToRemove.length) {\n      var root_1 = this;\n\n      while (root_1 instanceof Layer) root_1 = root_1.parent;\n\n      idsToRemove.forEach(function (id) {\n        return root_1.delete(id);\n      });\n    }\n\n    return idsToRemove;\n  };\n\n  EntityStore.prototype.findChildRefIds = function (dataId) {\n    if (!hasOwn.call(this.refs, dataId)) {\n      var found_1 = this.refs[dataId] = Object.create(null);\n      var workSet_1 = new Set([this.data[dataId]]);\n\n      var canTraverse_1 = function (obj) {\n        return obj !== null && typeof obj === 'object';\n      };\n\n      workSet_1.forEach(function (obj) {\n        if (isReference(obj)) {\n          found_1[obj.__ref] = true;\n        } else if (canTraverse_1(obj)) {\n          Object.values(obj).filter(canTraverse_1).forEach(workSet_1.add, workSet_1);\n        }\n      });\n    }\n\n    return this.refs[dataId];\n  };\n\n  EntityStore.prototype.makeCacheKey = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    return this.group.keyMaker.lookupArray(args);\n  };\n\n  return EntityStore;\n}();\n\nexport { EntityStore };\n\nvar CacheGroup = function () {\n  function CacheGroup(caching) {\n    this.caching = caching;\n    this.d = null;\n    this.keyMaker = new KeyTrie(canUseWeakMap);\n    this.d = caching ? dep() : null;\n  }\n\n  CacheGroup.prototype.depend = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      var fieldName = fieldNameFromStoreName(storeFieldName);\n\n      if (fieldName !== storeFieldName) {\n        this.d(makeDepKey(dataId, fieldName));\n      }\n    }\n  };\n\n  CacheGroup.prototype.dirty = function (dataId, storeFieldName) {\n    if (this.d) {\n      this.d.dirty(makeDepKey(dataId, storeFieldName));\n    }\n  };\n\n  return CacheGroup;\n}();\n\nfunction makeDepKey(dataId, storeFieldName) {\n  return storeFieldName + '#' + dataId;\n}\n\n(function (EntityStore) {\n  var Root = function (_super) {\n    __extends(Root, _super);\n\n    function Root(_a) {\n      var policies = _a.policies,\n          _b = _a.resultCaching,\n          resultCaching = _b === void 0 ? true : _b,\n          seed = _a.seed;\n\n      var _this = _super.call(this, policies, new CacheGroup(resultCaching)) || this;\n\n      _this.storageTrie = new KeyTrie(canUseWeakMap);\n      _this.sharedLayerGroup = new CacheGroup(resultCaching);\n      if (seed) _this.replace(seed);\n      return _this;\n    }\n\n    Root.prototype.addLayer = function (layerId, replay) {\n      return new Layer(layerId, this, replay, this.sharedLayerGroup);\n    };\n\n    Root.prototype.removeLayer = function () {\n      return this;\n    };\n\n    Root.prototype.getStorage = function () {\n      return this.storageTrie.lookupArray(arguments);\n    };\n\n    return Root;\n  }(EntityStore);\n\n  EntityStore.Root = Root;\n})(EntityStore || (EntityStore = {}));\n\nvar Layer = function (_super) {\n  __extends(Layer, _super);\n\n  function Layer(id, parent, replay, group) {\n    var _this = _super.call(this, parent.policies, group) || this;\n\n    _this.id = id;\n    _this.parent = parent;\n    _this.replay = replay;\n    _this.group = group;\n    replay(_this);\n    return _this;\n  }\n\n  Layer.prototype.addLayer = function (layerId, replay) {\n    return new Layer(layerId, this, replay, this.group);\n  };\n\n  Layer.prototype.removeLayer = function (layerId) {\n    var _this = this;\n\n    var parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      if (this.group.caching) {\n        Object.keys(this.data).forEach(function (dataId) {\n          if (_this.data[dataId] !== parent.lookup(dataId)) {\n            _this.delete(dataId);\n          }\n        });\n      }\n\n      return parent;\n    }\n\n    if (parent === this.parent) return this;\n    return parent.addLayer(this.id, this.replay);\n  };\n\n  Layer.prototype.toObject = function () {\n    return __assign(__assign({}, this.parent.toObject()), this.data);\n  };\n\n  Layer.prototype.findChildRefIds = function (dataId) {\n    var fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? __assign(__assign({}, fromParent), _super.prototype.findChildRefIds.call(this, dataId)) : fromParent;\n  };\n\n  Layer.prototype.getStorage = function () {\n    var p = this.parent;\n\n    while (p.parent) p = p.parent;\n\n    return p.getStorage.apply(p, arguments);\n  };\n\n  return Layer;\n}(EntityStore);\n\nfunction storeObjectReconciler(existingObject, incomingObject, property) {\n  var existingValue = existingObject[property];\n  var incomingValue = incomingObject[property];\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store) {\n  return !!(store instanceof EntityStore && store.group.caching);\n}","map":{"version":3,"mappings":"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","names":["dep","KeyTrie","equal","isReference","makeReference","DeepMerger","maybeDeepFreeze","canUseWeakMap","hasOwn","fieldNameFromStoreName","DELETE","Object","create","delModifier","INVALIDATE","policies","group","objectOrReference","storeFieldName","_this","get","__ref","objOrRef","has","objOrIdOrRef","mergeIntoStore","identify","id","ref","merge","EntityStore","data","dataId","lookup","fieldName","depend","call","storeObject","rootTypenamesById","Layer","parent","dependOnExistence","incoming","existing","merged","storeObjectReconciler","refs","caching","fieldsToDirty_1","__exists","keys","forEach","hasKeyArgs","__typename","dirty","fields","changedFields_1","needToMerge_1","allDeleted_1","sharedDetails_1","toReference","canRead","readField","fieldNameOrOptions","from","store","fieldValue","modify","newValue","__assign","storage","getStorage","args","typename","getFieldValue","getStoreFieldName","_a","options","evicted","delete","evict","replace","obj","toObject","extraRootIds","getRootIdSet","push","length","__META","sort","newData","rest_1","retain","rootId","rootIds","count","ids","Set","add","snapshot","findChildRefIds","idsToRemove","root_1","found_1","workSet_1","canTraverse_1","values","filter","keyMaker","lookupArray","d","CacheGroup","makeDepKey","__extends","_b","resultCaching","seed","_super","sharedLayerGroup","Root","layerId","replay","storageTrie","arguments","removeLayer","addLayer","fromParent","p","apply","existingObject","incomingObject","property","existingValue","incomingValue","supportsResultCaching"],"sourceRoot":"","sources":["../../../src/cache/inmemory/entityStore.ts"],"sourcesContent":["import { dep, OptimisticDependencyFunction, KeyTrie } from 'optimism';\nimport { equal } from '@wry/equality';\n\nimport {\n  isReference,\n  StoreValue,\n  StoreObject,\n  Reference,\n  makeReference,\n  DeepMerger,\n  maybeDeepFreeze,\n  canUseWeakMap,\n} from '../../utilities';\nimport { NormalizedCache, NormalizedCacheObject } from './types';\nimport { hasOwn, fieldNameFromStoreName } from './helpers';\nimport { Policies, StorageType } from './policies';\nimport { Cache } from '../core/types/Cache';\nimport {\n  SafeReadonly,\n  Modifier,\n  Modifiers,\n  ReadFieldOptions,\n  ToReferenceFunction,\n  CanReadFunction,\n} from '../core/types/common';\n\nconst DELETE: any = Object.create(null);\nconst delModifier: Modifier<any> = () => DELETE;\nconst INVALIDATE: any = Object.create(null);\n\nexport abstract class EntityStore implements NormalizedCache {\n  protected data: NormalizedCacheObject = Object.create(null);\n\n  constructor(\n    public readonly policies: Policies,\n    public readonly group: CacheGroup,\n  ) {}\n\n  public abstract addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer;\n\n  public abstract removeLayer(layerId: string): EntityStore;\n\n  // Although the EntityStore class is abstract, it contains concrete\n  // implementations of the various NormalizedCache interface methods that\n  // are inherited by the Root and Layer subclasses.\n\n  public toObject(): NormalizedCacheObject {\n    return { ...this.data };\n  }\n\n  public has(dataId: string): boolean {\n    return this.lookup(dataId, true) !== void 0;\n  }\n\n  public get(dataId: string, fieldName: string): StoreValue {\n    this.group.depend(dataId, fieldName);\n    if (hasOwn.call(this.data, dataId)) {\n      const storeObject = this.data[dataId];\n      if (storeObject && hasOwn.call(storeObject, fieldName)) {\n        return storeObject[fieldName];\n      }\n    }\n    if (fieldName === \"__typename\" &&\n        hasOwn.call(this.policies.rootTypenamesById, dataId)) {\n      return this.policies.rootTypenamesById[dataId];\n    }\n    if (this instanceof Layer) {\n      return this.parent.get(dataId, fieldName);\n    }\n  }\n\n  protected lookup(dataId: string, dependOnExistence?: boolean): StoreObject | undefined {\n    // The has method (above) calls lookup with dependOnExistence = true, so\n    // that it can later be invalidated when we add or remove a StoreObject for\n    // this dataId. Any consumer who cares about the contents of the StoreObject\n    // should not rely on this dependency, since the contents could change\n    // without the object being added or removed.\n    if (dependOnExistence) this.group.depend(dataId, \"__exists\");\n\n    if (hasOwn.call(this.data, dataId)) {\n      return this.data[dataId];\n    }\n\n    if (this instanceof Layer) {\n      return this.parent.lookup(dataId, dependOnExistence);\n    }\n\n    if (this.policies.rootTypenamesById[dataId]) {\n      return Object.create(null);\n    }\n  }\n\n  public merge(dataId: string, incoming: StoreObject): void {\n    const existing = this.lookup(dataId);\n    const merged: StoreObject =\n      new DeepMerger(storeObjectReconciler).merge(existing, incoming);\n    // Even if merged === existing, existing may have come from a lower\n    // layer, so we always need to set this.data[dataId] on this level.\n    this.data[dataId] = merged;\n    if (merged !== existing) {\n      delete this.refs[dataId];\n      if (this.group.caching) {\n        const fieldsToDirty: Record<string, 1> = Object.create(null);\n\n        // If we added a new StoreObject where there was previously none, dirty\n        // anything that depended on the existence of this dataId, such as the\n        // EntityStore#has method.\n        if (!existing) fieldsToDirty.__exists = 1;\n\n        // Now invalidate dependents who called getFieldValue for any fields\n        // that are changing as a result of this merge.\n        Object.keys(incoming).forEach(storeFieldName => {\n          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {\n            // Always dirty the full storeFieldName, which may include\n            // serialized arguments following the fieldName prefix.\n            fieldsToDirty[storeFieldName] = 1;\n\n            // Also dirty fieldNameFromStoreName(storeFieldName) if it's\n            // different from storeFieldName and this field does not have\n            // keyArgs configured, because that means the cache can't make\n            // any assumptions about how field values with the same field\n            // name but different arguments might be interrelated, so it\n            // must err on the side of invalidating all field values that\n            // share the same short fieldName, regardless of arguments.\n            const fieldName = fieldNameFromStoreName(storeFieldName);\n            if (fieldName !== storeFieldName &&\n                !this.policies.hasKeyArgs(merged.__typename, fieldName)) {\n              fieldsToDirty[fieldName] = 1;\n            }\n\n            // If merged[storeFieldName] has become undefined, and this is the\n            // Root layer, actually delete the property from the merged object,\n            // which is guaranteed to have been created fresh in this method.\n            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {\n              delete merged[storeFieldName];\n            }\n          }\n        });\n\n        Object.keys(fieldsToDirty).forEach(\n          fieldName => this.group.dirty(dataId, fieldName));\n      }\n    }\n  }\n\n  public modify(\n    dataId: string,\n    fields: Modifier<any> | Modifiers,\n  ): boolean {\n    const storeObject = this.lookup(dataId);\n\n    if (storeObject) {\n      const changedFields: Record<string, any> = Object.create(null);\n      let needToMerge = false;\n      let allDeleted = true;\n\n      const sharedDetails = {\n        DELETE,\n        INVALIDATE,\n        isReference,\n        toReference: this.toReference,\n        canRead: this.canRead,\n        readField: <V = StoreValue>(\n          fieldNameOrOptions: string | ReadFieldOptions,\n          from?: StoreObject | Reference,\n        ) => this.policies.readField<V>(\n          typeof fieldNameOrOptions === \"string\" ? {\n            fieldName: fieldNameOrOptions,\n            from: from || makeReference(dataId),\n          } : fieldNameOrOptions,\n          { store: this },\n        ),\n      };\n\n      Object.keys(storeObject).forEach(storeFieldName => {\n        const fieldName = fieldNameFromStoreName(storeFieldName);\n        let fieldValue = storeObject[storeFieldName];\n        if (fieldValue === void 0) return;\n        const modify: Modifier<StoreValue> = typeof fields === \"function\"\n          ? fields\n          : fields[storeFieldName] || fields[fieldName];\n        if (modify) {\n          let newValue = modify === delModifier ? DELETE :\n            modify(maybeDeepFreeze(fieldValue), {\n              ...sharedDetails,\n              fieldName,\n              storeFieldName,\n              storage: this.getStorage(dataId, storeFieldName),\n            });\n          if (newValue === INVALIDATE) {\n            this.group.dirty(dataId, storeFieldName);\n          } else {\n            if (newValue === DELETE) newValue = void 0;\n            if (newValue !== fieldValue) {\n              changedFields[storeFieldName] = newValue;\n              needToMerge = true;\n              fieldValue = newValue;\n            }\n          }\n        }\n        if (fieldValue !== void 0) {\n          allDeleted = false;\n        }\n      });\n\n      if (needToMerge) {\n        this.merge(dataId, changedFields);\n\n        if (allDeleted) {\n          if (this instanceof Layer) {\n            this.data[dataId] = void 0;\n          } else {\n            delete this.data[dataId];\n          }\n          this.group.dirty(dataId, \"__exists\");\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // If called with only one argument, removes the entire entity\n  // identified by dataId. If called with a fieldName as well, removes all\n  // fields of that entity whose names match fieldName according to the\n  // fieldNameFromStoreName helper function. If called with a fieldName\n  // and variables, removes all fields of that entity whose names match fieldName\n  // and whose arguments when cached exactly match the variables passed.\n  public delete(\n    dataId: string,\n    fieldName?: string,\n    args?: Record<string, any>,\n  ) {\n    const storeObject = this.lookup(dataId);\n    if (storeObject) {\n      const typename = this.getFieldValue<string>(storeObject, \"__typename\");\n      const storeFieldName = fieldName && args\n        ? this.policies.getStoreFieldName({ typename, fieldName, args })\n        : fieldName;\n      return this.modify(dataId, storeFieldName ? {\n        [storeFieldName]: delModifier,\n      } : delModifier);\n    }\n    return false;\n  }\n\n  public evict(options: Cache.EvictOptions): boolean {\n    let evicted = false;\n    if (options.id) {\n      if (hasOwn.call(this.data, options.id)) {\n        evicted = this.delete(options.id, options.fieldName, options.args);\n      }\n      if (this instanceof Layer) {\n        evicted = this.parent.evict(options) || evicted;\n      }\n      // Always invalidate the field to trigger rereading of watched\n      // queries, even if no cache data was modified by the eviction,\n      // because queries may depend on computed fields with custom read\n      // functions, whose values are not stored in the EntityStore.\n      if (options.fieldName || evicted) {\n        this.group.dirty(options.id, options.fieldName || \"__exists\");\n      }\n    }\n    return evicted;\n  }\n\n  public clear(): void {\n    this.replace(null);\n  }\n\n  public extract(): NormalizedCacheObject {\n    const obj = this.toObject();\n    const extraRootIds: string[] = [];\n    this.getRootIdSet().forEach(id => {\n      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {\n        extraRootIds.push(id);\n      }\n    });\n    if (extraRootIds.length) {\n      obj.__META = { extraRootIds: extraRootIds.sort() };\n    }\n    return obj;\n  }\n\n  public replace(newData: NormalizedCacheObject | null): void {\n    Object.keys(this.data).forEach(dataId => {\n      if (!(newData && hasOwn.call(newData, dataId))) {\n        this.delete(dataId);\n      }\n    });\n    if (newData) {\n      const { __META, ...rest } = newData;\n      Object.keys(rest).forEach(dataId => {\n        this.merge(dataId, rest[dataId] as StoreObject);\n      });\n      if (__META) {\n        __META.extraRootIds.forEach(this.retain, this);\n      }\n    }\n  }\n\n  public abstract getStorage(\n    idOrObj: string | StoreObject,\n    ...storeFieldNames: (string | number)[]\n  ): StorageType;\n\n  // Maps root entity IDs to the number of times they have been retained, minus\n  // the number of times they have been released. Retained entities keep other\n  // entities they reference (even indirectly) from being garbage collected.\n  private rootIds: {\n    [rootId: string]: number;\n  } = Object.create(null);\n\n  public retain(rootId: string): number {\n    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;\n  }\n\n  public release(rootId: string): number {\n    if (this.rootIds[rootId] > 0) {\n      const count = --this.rootIds[rootId];\n      if (!count) delete this.rootIds[rootId];\n      return count;\n    }\n    return 0;\n  }\n\n  // Return a Set<string> of all the ID strings that have been retained by\n  // this layer/root *and* any layers/roots beneath it.\n  public getRootIdSet(ids = new Set<string>()) {\n    Object.keys(this.rootIds).forEach(ids.add, ids);\n    if (this instanceof Layer) {\n      this.parent.getRootIdSet(ids);\n    } else {\n      // Official singleton IDs like ROOT_QUERY and ROOT_MUTATION are\n      // always considered roots for garbage collection, regardless of\n      // their retainment counts in this.rootIds.\n      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);\n    }\n    return ids;\n  }\n\n  // The goal of garbage collection is to remove IDs from the Root layer of the\n  // store that are no longer reachable starting from any IDs that have been\n  // explicitly retained (see retain and release, above). Returns an array of\n  // dataId strings that were removed from the store.\n  public gc() {\n    const ids = this.getRootIdSet();\n    const snapshot = this.toObject();\n    ids.forEach(id => {\n      if (hasOwn.call(snapshot, id)) {\n        // Because we are iterating over an ECMAScript Set, the IDs we add here\n        // will be visited in later iterations of the forEach loop only if they\n        // were not previously contained by the Set.\n        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);\n        // By removing IDs from the snapshot object here, we protect them from\n        // getting removed from the root store layer below.\n        delete snapshot[id];\n      }\n    });\n    const idsToRemove = Object.keys(snapshot);\n    if (idsToRemove.length) {\n      let root: EntityStore = this;\n      while (root instanceof Layer) root = root.parent;\n      idsToRemove.forEach(id => root.delete(id));\n    }\n    return idsToRemove;\n  }\n\n  // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].\n  private refs: {\n    [dataId: string]: Record<string, true>;\n  } = Object.create(null);\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    if (!hasOwn.call(this.refs, dataId)) {\n      const found = this.refs[dataId] = Object.create(null);\n      const workSet = new Set([this.data[dataId]]);\n      // Within the store, only arrays and objects can contain child entity\n      // references, so we can prune the traversal using this predicate:\n      const canTraverse = (obj: any) => obj !== null && typeof obj === 'object';\n      workSet.forEach(obj => {\n        if (isReference(obj)) {\n          found[obj.__ref] = true;\n        } else if (canTraverse(obj)) {\n          Object.values(obj!)\n            // No need to add primitive values to the workSet, since they cannot\n            // contain reference objects.\n            .filter(canTraverse)\n            .forEach(workSet.add, workSet);\n        }\n      });\n    }\n    return this.refs[dataId];\n  }\n\n  // Used to compute cache keys specific to this.group.\n  public makeCacheKey(...args: any[]) {\n    return this.group.keyMaker.lookupArray(args);\n  }\n\n  // Bound function that can be passed around to provide easy access to fields\n  // of Reference objects as well as ordinary objects.\n  public getFieldValue = <T = StoreValue>(\n    objectOrReference: StoreObject | Reference | undefined,\n    storeFieldName: string,\n  ) => maybeDeepFreeze(\n    isReference(objectOrReference)\n      ? this.get(objectOrReference.__ref, storeFieldName)\n      : objectOrReference && objectOrReference[storeFieldName]\n  ) as SafeReadonly<T>;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  public canRead: CanReadFunction = objOrRef => {\n    return isReference(objOrRef)\n      ? this.has(objOrRef.__ref)\n      : typeof objOrRef === \"object\";\n  };\n\n  // Bound function that converts an id or an object with a __typename and\n  // primary key fields to a Reference object. If called with a Reference object,\n  // that same Reference object is returned. Pass true for mergeIntoStore to persist\n  // an object into the store.\n  public toReference: ToReferenceFunction = (\n    objOrIdOrRef,\n    mergeIntoStore,\n  ) => {\n    if (typeof objOrIdOrRef === \"string\") {\n      return makeReference(objOrIdOrRef);\n    }\n\n    if (isReference(objOrIdOrRef)) {\n      return objOrIdOrRef;\n    }\n\n    const [id] = this.policies.identify(objOrIdOrRef);\n\n    if (id) {\n      const ref = makeReference(id);\n      if (mergeIntoStore) {\n        this.merge(id, objOrIdOrRef);\n      }\n      return ref;\n    }\n  };\n}\n\nexport type FieldValueGetter = EntityStore[\"getFieldValue\"];\n\n// A single CacheGroup represents a set of one or more EntityStore objects,\n// typically the Root store in a CacheGroup by itself, and all active Layer\n// stores in a group together. A single EntityStore object belongs to only\n// one CacheGroup, store.group. The CacheGroup is responsible for tracking\n// dependencies, so store.group is helpful for generating unique keys for\n// cached results that need to be invalidated when/if those dependencies\n// change. If we used the EntityStore objects themselves as cache keys (that\n// is, store rather than store.group), the cache would become unnecessarily\n// fragmented by all the different Layer objects. Instead, the CacheGroup\n// approach allows all optimistic Layer objects in the same linked list to\n// belong to one CacheGroup, with the non-optimistic Root object belonging\n// to another CacheGroup, allowing resultCaching dependencies to be tracked\n// separately for optimistic and non-optimistic entity data.\nclass CacheGroup {\n  private d: OptimisticDependencyFunction<string> | null = null;\n\n  constructor(public readonly caching: boolean) {\n    this.d = caching ? dep<string>() : null;\n  }\n\n  public depend(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d(makeDepKey(dataId, storeFieldName));\n      const fieldName = fieldNameFromStoreName(storeFieldName);\n      if (fieldName !== storeFieldName) {\n        // Fields with arguments that contribute extra identifying\n        // information to the fieldName (thus forming the storeFieldName)\n        // depend not only on the full storeFieldName but also on the\n        // short fieldName, so the field can be invalidated using either\n        // level of specificity.\n        this.d(makeDepKey(dataId, fieldName));\n      }\n    }\n  }\n\n  public dirty(dataId: string, storeFieldName: string) {\n    if (this.d) {\n      this.d.dirty(makeDepKey(dataId, storeFieldName));\n    }\n  }\n\n  // Used by the EntityStore#makeCacheKey method to compute cache keys\n  // specific to this CacheGroup.\n  public readonly keyMaker = new KeyTrie<object>(canUseWeakMap);\n}\n\nfunction makeDepKey(dataId: string, storeFieldName: string) {\n  // Since field names cannot have '#' characters in them, this method\n  // of joining the field name and the ID should be unambiguous, and much\n  // cheaper than JSON.stringify([dataId, fieldName]).\n  return storeFieldName + '#' + dataId;\n}\n\nexport namespace EntityStore {\n  // Refer to this class as EntityStore.Root outside this namespace.\n  export class Root extends EntityStore {\n    // Although each Root instance gets its own unique CacheGroup object,\n    // any Layer instances created by calling addLayer need to share a\n    // single distinct CacheGroup object. Since this shared object must\n    // outlast the Layer instances themselves, it needs to be created and\n    // owned by the Root instance.\n    private sharedLayerGroup: CacheGroup;\n\n    constructor({\n      policies,\n      resultCaching = true,\n      seed,\n    }: {\n      policies: Policies;\n      resultCaching?: boolean;\n      seed?: NormalizedCacheObject;\n    }) {\n      super(policies, new CacheGroup(resultCaching));\n      this.sharedLayerGroup = new CacheGroup(resultCaching);\n      if (seed) this.replace(seed);\n    }\n\n    public addLayer(\n      layerId: string,\n      replay: (layer: EntityStore) => any,\n    ): Layer {\n      // The replay function will be called in the Layer constructor.\n      return new Layer(layerId, this, replay, this.sharedLayerGroup);\n    }\n\n    public removeLayer(): Root {\n      // Never remove the root layer.\n      return this;\n    }\n\n    public readonly storageTrie = new KeyTrie<StorageType>(canUseWeakMap);\n    public getStorage(): StorageType {\n      return this.storageTrie.lookupArray(arguments);\n    }\n  }\n}\n\n// Not exported, since all Layer instances are created by the addLayer method\n// of the EntityStore.Root class.\nclass Layer extends EntityStore {\n  constructor(\n    public readonly id: string,\n    public readonly parent: EntityStore,\n    public readonly replay: (layer: EntityStore) => any,\n    public readonly group: CacheGroup,\n  ) {\n    super(parent.policies, group);\n    replay(this);\n  }\n\n  public addLayer(\n    layerId: string,\n    replay: (layer: EntityStore) => any,\n  ): Layer {\n    return new Layer(layerId, this, replay, this.group);\n  }\n\n  public removeLayer(layerId: string): EntityStore {\n    // Remove all instances of the given id, not just the first one.\n    const parent = this.parent.removeLayer(layerId);\n\n    if (layerId === this.id) {\n      // Dirty every ID we're removing.\n      if (this.group.caching) {\n        Object.keys(this.data).forEach(dataId => {\n          // If this.data[dataId] contains nothing different from what\n          // lies beneath, we can avoid dirtying this dataId and all of\n          // its fields, and simply discard this Layer. The only reason we\n          // call this.delete here is to dirty the removed fields.\n          if (this.data[dataId] !== (parent as Layer).lookup(dataId)) {\n            this.delete(dataId);\n          }\n        });\n      }\n      return parent;\n    }\n\n    // No changes are necessary if the parent chain remains identical.\n    if (parent === this.parent) return this;\n\n    // Recreate this layer on top of the new parent.\n    return parent.addLayer(this.id, this.replay);\n  }\n\n  public toObject(): NormalizedCacheObject {\n    return {\n      ...this.parent.toObject(),\n      ...this.data,\n    };\n  }\n\n  public findChildRefIds(dataId: string): Record<string, true> {\n    const fromParent = this.parent.findChildRefIds(dataId);\n    return hasOwn.call(this.data, dataId) ? {\n      ...fromParent,\n      ...super.findChildRefIds(dataId),\n    } : fromParent;\n  }\n\n  public getStorage(): StorageType {\n    let p: EntityStore = this.parent;\n    while ((p as Layer).parent) p = (p as Layer).parent;\n    return p.getStorage.apply(p, arguments);\n  }\n}\n\nfunction storeObjectReconciler(\n  existingObject: StoreObject,\n  incomingObject: StoreObject,\n  property: string,\n): StoreValue {\n  const existingValue = existingObject[property];\n  const incomingValue = incomingObject[property];\n  // Wherever there is a key collision, prefer the incoming value, unless\n  // it is deeply equal to the existing value. It's worth checking deep\n  // equality here (even though blindly returning incoming would be\n  // logically correct) because preserving the referential identity of\n  // existing data can prevent needless rereading and rerendering.\n  return equal(existingValue, incomingValue) ? existingValue : incomingValue;\n}\n\nexport function supportsResultCaching(store: any): store is EntityStore {\n  // When result caching is disabled, store.depend will be null.\n  return !!(store instanceof EntityStore && store.group.caching);\n}\n"]},"metadata":{},"sourceType":"module"}