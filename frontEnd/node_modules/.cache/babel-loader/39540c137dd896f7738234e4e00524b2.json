{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection, isField, getTypenameFromResult, storeKeyNameFromField, argumentsObjectFromField, isReference, getStoreKeyName, canUseWeakMap, compact } from \"../../utilities/index.js\";\nimport { hasOwn, fieldNameFromStoreName, storeValueIsStoreObject, selectionSetMatchesResult, TypeOrFieldNameRegExp } from \"./helpers.js\";\nimport { cacheSlot } from \"./reactiveVars.js\";\n\nfunction argsFromFieldSpecifier(spec) {\n  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport var defaultDataIdFromObject = function (_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = id !== void 0 ? {\n        id: id\n      } : _id !== void 0 ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (id === void 0) id = _id;\n\n    if (id !== void 0) {\n      return __typename + \":\" + (typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n};\n\nvar nullKeyFieldsFn = function () {\n  return void 0;\n};\n\nvar simpleKeyArgsFn = function (_args, context) {\n  return context.fieldName;\n};\n\nvar mergeTrueFn = function (existing, incoming, _a) {\n  var mergeObjects = _a.mergeObjects;\n  return mergeObjects(existing, incoming);\n};\n\nvar mergeFalseFn = function (_, incoming) {\n  return incoming;\n};\n\nvar Policies = function () {\n  function Policies(config) {\n    this.config = config;\n    this.typePolicies = Object.create(null);\n    this.toBeAdded = Object.create(null);\n    this.supertypeMap = new Map();\n    this.fuzzySubtypes = new Map();\n    this.rootIdsByTypename = Object.create(null);\n    this.rootTypenamesById = Object.create(null);\n    this.usingPossibleTypes = false;\n    this.config = __assign({\n      dataIdFromObject: defaultDataIdFromObject\n    }, config);\n    this.cache = this.config.cache;\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  Policies.prototype.identify = function (object, selectionSet, fragmentMap) {\n    var typename = selectionSet && fragmentMap ? getTypenameFromResult(object, selectionSet, fragmentMap) : object.__typename;\n\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    var context = {\n      typename: typename,\n      selectionSet: selectionSet,\n      fragmentMap: fragmentMap\n    };\n    var id;\n    var policy = typename && this.getTypePolicy(typename);\n    var keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n\n    while (keyFn) {\n      var specifierOrId = keyFn(object, context);\n\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n    return context.keyObject ? [id, context.keyObject] : [id];\n  };\n\n  Policies.prototype.addTypePolicies = function (typePolicies) {\n    var _this = this;\n\n    Object.keys(typePolicies).forEach(function (typename) {\n      var _a = typePolicies[typename],\n          queryType = _a.queryType,\n          mutationType = _a.mutationType,\n          subscriptionType = _a.subscriptionType,\n          incoming = __rest(_a, [\"queryType\", \"mutationType\", \"subscriptionType\"]);\n\n      if (queryType) _this.setRootTypename(\"Query\", typename);\n      if (mutationType) _this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) _this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(_this.toBeAdded, typename)) {\n        _this.toBeAdded[typename].push(incoming);\n      } else {\n        _this.toBeAdded[typename] = [incoming];\n      }\n    });\n  };\n\n  Policies.prototype.updateTypePolicy = function (typename, incoming) {\n    var _this = this;\n\n    var existing = this.getTypePolicy(typename);\n    var keyFields = incoming.keyFields,\n        fields = incoming.fields;\n\n    function setMerge(existing, merge) {\n      existing.merge = typeof merge === \"function\" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing.merge;\n    }\n\n    setMerge(existing, incoming.merge);\n    existing.keyFn = keyFields === false ? nullKeyFieldsFn : Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === \"function\" ? keyFields : existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(function (fieldName) {\n        var existing = _this.getFieldPolicy(typename, fieldName, true);\n\n        var incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          var keyArgs = incoming.keyArgs,\n              read = incoming.read,\n              merge = incoming.merge;\n          existing.keyFn = keyArgs === false ? simpleKeyArgsFn : Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === \"function\" ? keyArgs : existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  };\n\n  Policies.prototype.setRootTypename = function (which, typename) {\n    if (typename === void 0) {\n      typename = which;\n    }\n\n    var rootId = \"ROOT_\" + which.toUpperCase();\n    var old = this.rootTypenamesById[rootId];\n\n    if (typename !== old) {\n      process.env.NODE_ENV === \"production\" ? invariant(!old || old === which, 1) : invariant(!old || old === which, \"Cannot change root \" + which + \" __typename more than once\");\n      if (old) delete this.rootIdsByTypename[old];\n      this.rootIdsByTypename[typename] = rootId;\n      this.rootTypenamesById[rootId] = typename;\n    }\n  };\n\n  Policies.prototype.addPossibleTypes = function (possibleTypes) {\n    var _this = this;\n\n    this.usingPossibleTypes = true;\n    Object.keys(possibleTypes).forEach(function (supertype) {\n      _this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(function (subtype) {\n        _this.getSupertypeSet(subtype, true).add(supertype);\n\n        var match = subtype.match(TypeOrFieldNameRegExp);\n\n        if (!match || match[0] !== subtype) {\n          _this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  };\n\n  Policies.prototype.getTypePolicy = function (typename) {\n    var _this = this;\n\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      var policy_1 = this.typePolicies[typename] = Object.create(null);\n      policy_1.fields = Object.create(null);\n      var supertypes = this.supertypeMap.get(typename);\n\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(function (supertype) {\n          var _a = _this.getTypePolicy(supertype),\n              fields = _a.fields,\n              rest = __rest(_a, [\"fields\"]);\n\n          Object.assign(policy_1, rest);\n          Object.assign(policy_1.fields, fields);\n        });\n      }\n    }\n\n    var inbox = this.toBeAdded[typename];\n\n    if (inbox && inbox.length) {\n      this.updateTypePolicy(typename, compact.apply(void 0, inbox.splice(0)));\n    }\n\n    return this.typePolicies[typename];\n  };\n\n  Policies.prototype.getFieldPolicy = function (typename, fieldName, createIfMissing) {\n    if (typename) {\n      var fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || createIfMissing && (fieldPolicies[fieldName] = Object.create(null));\n    }\n  };\n\n  Policies.prototype.getSupertypeSet = function (subtype, createIfMissing) {\n    var supertypeSet = this.supertypeMap.get(subtype);\n\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set());\n    }\n\n    return supertypeSet;\n  };\n\n  Policies.prototype.fragmentMatches = function (fragment, typename, result, variables) {\n    var _this = this;\n\n    if (!fragment.typeCondition) return true;\n    if (!typename) return false;\n    var supertype = fragment.typeCondition.name.value;\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {\n      var typenameSupertypeSet = this.getSupertypeSet(typename, true);\n      var workQueue_1 = [typenameSupertypeSet];\n\n      var maybeEnqueue_1 = function (subtype) {\n        var supertypeSet = _this.getSupertypeSet(subtype, false);\n\n        if (supertypeSet && supertypeSet.size && workQueue_1.indexOf(supertypeSet) < 0) {\n          workQueue_1.push(supertypeSet);\n        }\n      };\n\n      var needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      var checkingFuzzySubtypes = false;\n\n      for (var i = 0; i < workQueue_1.length; ++i) {\n        var supertypeSet = workQueue_1[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              process.env.NODE_ENV === \"production\" || invariant.warn(\"Inferring subtype \" + typename + \" of supertype \" + supertype);\n            }\n\n            typenameSupertypeSet.add(supertype);\n          }\n\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue_1);\n\n        if (needToCheckFuzzySubtypes && i === workQueue_1.length - 1 && selectionSetMatchesResult(fragment.selectionSet, result, variables)) {\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n          this.fuzzySubtypes.forEach(function (regExp, fuzzyString) {\n            var match = typename.match(regExp);\n\n            if (match && match[0] === typename) {\n              maybeEnqueue_1(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  };\n\n  Policies.prototype.hasKeyArgs = function (typename, fieldName) {\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  };\n\n  Policies.prototype.getStoreFieldName = function (fieldSpec) {\n    var typename = fieldSpec.typename,\n        fieldName = fieldSpec.fieldName;\n    var policy = this.getFieldPolicy(typename, fieldName, false);\n    var storeFieldName;\n    var keyFn = policy && policy.keyFn;\n\n    if (keyFn && typename) {\n      var context = {\n        typename: typename,\n        fieldName: fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables\n      };\n      var args = argsFromFieldSpecifier(fieldSpec);\n\n      while (keyFn) {\n        var specifierOrString = keyFn(args, context);\n\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + \":\" + storeFieldName;\n  };\n\n  Policies.prototype.readField = function (options, context) {\n    var objectOrReference = options.from;\n    if (!objectOrReference) return;\n    var nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      var typename = context.store.getFieldValue(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    var storeFieldName = this.getStoreFieldName(options);\n    var fieldName = fieldNameFromStoreName(storeFieldName);\n    var existing = context.store.getFieldValue(objectOrReference, storeFieldName);\n    var policy = this.getFieldPolicy(options.typename, fieldName, false);\n    var read = policy && policy.read;\n\n    if (read) {\n      var readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));\n      return cacheSlot.withValue(this.cache, read, [existing, readOptions]);\n    }\n\n    return existing;\n  };\n\n  Policies.prototype.getMergeFunction = function (parentTypename, fieldName, childTypename) {\n    var policy = this.getFieldPolicy(parentTypename, fieldName, false);\n    var merge = policy && policy.merge;\n\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n\n    return merge;\n  };\n\n  Policies.prototype.runMergeFunction = function (existing, incoming, _a, context, storage) {\n    var field = _a.field,\n        typename = _a.typename,\n        merge = _a.merge;\n\n    if (merge === mergeTrueFn) {\n      return makeMergeObjectsFunction(context.store.getFieldValue)(existing, incoming);\n    }\n\n    if (merge === mergeFalseFn) {\n      return incoming;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(this, void 0, {\n      typename: typename,\n      fieldName: field.name.value,\n      field: field,\n      variables: context.variables\n    }, context, storage || Object.create(null)));\n  };\n\n  return Policies;\n}();\n\nexport { Policies };\n\nfunction makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {\n  var storeFieldName = policies.getStoreFieldName(fieldSpec);\n  var fieldName = fieldNameFromStoreName(storeFieldName);\n  var variables = fieldSpec.variables || context.variables;\n  var _a = context.store,\n      getFieldValue = _a.getFieldValue,\n      toReference = _a.toReference,\n      canRead = _a.canRead;\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName: fieldName,\n    storeFieldName: storeFieldName,\n    variables: variables,\n    isReference: isReference,\n    toReference: toReference,\n    storage: storage,\n    cache: policies.cache,\n    canRead: canRead,\n    readField: function (fieldNameOrOptions, from) {\n      var options = typeof fieldNameOrOptions === \"string\" ? {\n        fieldName: fieldNameOrOptions,\n        from: from\n      } : __assign({}, fieldNameOrOptions);\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField(options, context);\n    },\n    mergeObjects: makeMergeObjectsFunction(getFieldValue)\n  };\n}\n\nfunction makeMergeObjectsFunction(getFieldValue) {\n  return function mergeObjects(existing, incoming) {\n    if (Array.isArray(existing) || Array.isArray(incoming)) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(2) : new InvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    if (existing && typeof existing === \"object\" && incoming && typeof incoming === \"object\") {\n      var eType = getFieldValue(existing, \"__typename\");\n      var iType = getFieldValue(incoming, \"__typename\");\n      var typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer || !storeValueIsStoreObject(existing) || !storeValueIsStoreObject(incoming)) {\n        return incoming;\n      }\n\n      return __assign(__assign({}, existing), incoming);\n    }\n\n    return incoming;\n  };\n}\n\nfunction keyArgsFnFromSpecifier(specifier) {\n  return function (args, context) {\n    return args ? context.fieldName + \":\" + JSON.stringify(computeKeyObject(args, specifier, false)) : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(specifier) {\n  var trie = new KeyTrie(canUseWeakMap);\n  return function (object, context) {\n    var aliasMap;\n\n    if (context.selectionSet && context.fragmentMap) {\n      var info = trie.lookupArray([context.selectionSet, context.fragmentMap]);\n      aliasMap = info.aliasMap || (info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap));\n    }\n\n    var keyObject = context.keyObject = computeKeyObject(object, specifier, true, aliasMap);\n    return context.typename + \":\" + JSON.stringify(keyObject);\n  };\n}\n\nfunction makeAliasMap(selectionSet, fragmentMap) {\n  var map = Object.create(null);\n  var workQueue = new Set([selectionSet]);\n  workQueue.forEach(function (selectionSet) {\n    selectionSet.selections.forEach(function (selection) {\n      if (isField(selection)) {\n        if (selection.alias) {\n          var responseKey = selection.alias.value;\n          var storeKey = selection.name.value;\n\n          if (storeKey !== responseKey) {\n            var aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n\n        if (selection.selectionSet) {\n          var subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] = makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        var fragment = getFragmentFromSelection(selection, fragmentMap);\n\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(response, specifier, strict, aliasMap) {\n  var keyObj = Object.create(null);\n  var prevKey;\n  specifier.forEach(function (s) {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        var subsets = aliasMap && aliasMap.subsets;\n        var subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, strict, subset);\n      }\n    } else {\n      var aliases = aliasMap && aliasMap.aliases;\n      var responseName = aliases && aliases[s] || s;\n\n      if (hasOwn.call(response, responseName)) {\n        keyObj[prevKey = s] = response[responseName];\n      } else {\n        process.env.NODE_ENV === \"production\" ? invariant(!strict, 3) : invariant(!strict, \"Missing field '\" + responseName + \"' while computing key fields\");\n        prevKey = void 0;\n      }\n    }\n  });\n  return keyObj;\n}","map":{"version":3,"mappings":"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","names":["KeyTrie","invariant","InvariantError","getFragmentFromSelection","isField","getTypenameFromResult","storeKeyNameFromField","argumentsObjectFromField","isReference","getStoreKeyName","canUseWeakMap","compact","hasOwn","fieldNameFromStoreName","storeValueIsStoreObject","selectionSetMatchesResult","TypeOrFieldNameRegExp","cacheSlot","argsFromFieldSpecifier","spec","args","field","variables","defaultDataIdFromObject","_a","context","__typename","id","_id","keyObject","JSON","stringify","nullKeyFieldsFn","simpleKeyArgsFn","_args","fieldName","mergeTrueFn","existing","incoming","mergeObjects","mergeFalseFn","_","config","Object","create","Map","__assign","dataIdFromObject","cache","setRootTypename","possibleTypes","addPossibleTypes","typePolicies","addTypePolicies","Policies","object","selectionSet","fragmentMap","typename","rootTypenamesById","ROOT_QUERY","policy","getTypePolicy","keyFn","specifierOrId","Array","isArray","keyFieldsFnFromSpecifier","String","keys","forEach","queryType","mutationType","subscriptionType","_this","call","toBeAdded","push","fields","setMerge","merge","keyFields","getFieldPolicy","read","keyArgs","keyArgsFnFromSpecifier","which","rootId","toUpperCase","old","process","NODE_ENV","rootIdsByTypename","usingPossibleTypes","getSupertypeSet","supertype","subtype","add","match","fuzzySubtypes","set","RegExp","policy_1","supertypes","supertypeMap","get","size","rest","assign","inbox","length","updateTypePolicy","splice","createIfMissing","fieldPolicies","supertypeSet","Set","fragment","result","typeCondition","name","value","has","typenameSupertypeSet","workQueue_1","maybeEnqueue_1","indexOf","needToCheckFuzzySubtypes","checkingFuzzySubtypes","i","regExp","fuzzyString","fieldSpec","storeFieldName","specifierOrString","options","objectOrReference","from","nameOrField","store","getFieldValue","getStoreFieldName","readOptions","makeFieldFunctionOptions","getStorage","__ref","withValue","parentTypename","childTypename","storage","makeMergeObjectsFunction","policies","toReference","canRead","readField","fieldNameOrOptions","eType","iType","typesDiffer","specifier","computeKeyObject","trie","aliasMap","info","lookupArray","makeAliasMap","map","workQueue","selections","selection","alias","responseKey","storeKey","aliases","subsets","response","strict","keyObj","prevKey","s","subset","responseName"],"sourceRoot":"","sources":["../../../src/cache/inmemory/policies.ts"],"sourcesContent":["import {\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  SelectionSetNode,\n  FieldNode,\n} from 'graphql';\n\nimport { KeyTrie } from 'optimism';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  FragmentMap,\n  getFragmentFromSelection,\n  isField,\n  getTypenameFromResult,\n  storeKeyNameFromField,\n  StoreValue,\n  StoreObject,\n  argumentsObjectFromField,\n  Reference,\n  isReference,\n  getStoreKeyName,\n  canUseWeakMap,\n  compact,\n} from '../../utilities';\nimport { IdGetter, ReadMergeModifyContext, MergeInfo } from \"./types\";\nimport {\n  hasOwn,\n  fieldNameFromStoreName,\n  storeValueIsStoreObject,\n  selectionSetMatchesResult,\n  TypeOrFieldNameRegExp,\n} from './helpers';\nimport { cacheSlot } from './reactiveVars';\nimport { InMemoryCache } from './inMemoryCache';\nimport {\n  SafeReadonly,\n  FieldSpecifier,\n  ToReferenceFunction,\n  ReadFieldFunction,\n  ReadFieldOptions,\n  CanReadFunction,\n} from '../core/types/common';\nimport { FieldValueGetter } from './entityStore';\n\nexport type TypePolicies = {\n  [__typename: string]: TypePolicy;\n}\n\n// TypeScript 3.7 will allow recursive type aliases, so this should work:\n// type KeySpecifier = (string | KeySpecifier)[]\ntype KeySpecifier = (string | any[])[];\n\ntype KeyFieldsContext = {\n  typename?: string;\n  selectionSet?: SelectionSetNode;\n  fragmentMap?: FragmentMap;\n  // May be set by the KeyFieldsFunction to report fields that were involved\n  // in computing the ID. Never passed in by the caller.\n  keyObject?: Record<string, any>;\n};\n\nexport type KeyFieldsFunction = (\n  object: Readonly<StoreObject>,\n  context: KeyFieldsContext,\n) => KeySpecifier | ReturnType<IdGetter>;\n\n// TODO Should TypePolicy be a generic type, with a TObject or TEntity\n// type parameter?\nexport type TypePolicy = {\n  // Allows defining the primary key fields for this type, either using an\n  // array of field names or a function that returns an arbitrary string.\n  keyFields?: KeySpecifier | KeyFieldsFunction | false;\n\n  // Allows defining a merge function (or merge:true/false shorthand) to\n  // be used for merging objects of this type wherever they appear, unless\n  // the parent field also defines a merge function/boolean (that is,\n  // parent field merge functions take precedence over type policy merge\n  // functions). In many cases, defining merge:true for a given type\n  // policy can save you from specifying merge:true for all the field\n  // policies where that type might be encountered.\n  merge?: FieldMergeFunction | boolean;\n\n  // In the rare event that your schema happens to use a different\n  // __typename for the root Query, Mutation, and/or Schema types, you can\n  // express your deviant preferences by enabling one of these options.\n  queryType?: true,\n  mutationType?: true,\n  subscriptionType?: true,\n\n  fields?: {\n    [fieldName: string]:\n      | FieldPolicy<any>\n      | FieldReadFunction<any>;\n  }\n};\n\nexport type KeyArgsFunction = (\n  args: Record<string, any> | null,\n  context: {\n    typename: string;\n    fieldName: string;\n    field: FieldNode | null;\n    variables?: Record<string, any>;\n  },\n) => KeySpecifier | ReturnType<IdGetter>;\n\nexport type FieldPolicy<\n  // The internal representation used to store the field's data in the\n  // cache. Must be JSON-serializable if you plan to serialize the result\n  // of cache.extract() using JSON.\n  TExisting = any,\n  // The type of the incoming parameter passed to the merge function,\n  // typically matching the GraphQL response format, but with Reference\n  // objects substituted for any identifiable child objects. Often the\n  // same as TExisting, but not necessarily.\n  TIncoming = TExisting,\n  // The type that the read function actually returns, using TExisting\n  // data and options.args as input. Usually the same as TIncoming.\n  TReadResult = TIncoming,\n> = {\n  keyArgs?: KeySpecifier | KeyArgsFunction | false;\n  read?: FieldReadFunction<TExisting, TReadResult>;\n  merge?: FieldMergeFunction<TExisting, TIncoming> | boolean;\n};\n\nexport type StorageType = Record<string, any>;\n\nfunction argsFromFieldSpecifier(spec: FieldSpecifier) {\n  return spec.args !== void 0 ? spec.args :\n    spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;\n}\n\nexport interface FieldFunctionOptions<\n  TArgs = Record<string, any>,\n  TVars = Record<string, any>,\n> {\n  args: TArgs | null;\n\n  // The name of the field, equal to options.field.name.value when\n  // options.field is available. Useful if you reuse the same function for\n  // multiple fields, and you need to know which field you're currently\n  // processing. Always a string, even when options.field is null.\n  fieldName: string;\n\n  // The full field key used internally, including serialized key arguments.\n  storeFieldName: string;\n\n  // The FieldNode object used to read this field. Useful if you need to\n  // know about other attributes of the field, such as its directives. This\n  // option will be null when a string was passed to options.readField.\n  field: FieldNode | null;\n\n  variables?: TVars;\n\n  // Utilities for dealing with { __ref } objects.\n  isReference: typeof isReference;\n  toReference: ToReferenceFunction;\n\n  // A handy place to put field-specific data that you want to survive\n  // across multiple read function calls. Useful for field-level caching,\n  // if your read function does any expensive work.\n  storage: StorageType;\n\n  cache: InMemoryCache;\n\n  // Helper function for reading other fields within the current object.\n  // If a foreign object or reference is provided, the field will be read\n  // from that object instead of the current object, so this function can\n  // be used (together with isReference) to examine the cache outside the\n  // current object. If a FieldNode is passed instead of a string, and\n  // that FieldNode has arguments, the same options.variables will be used\n  // to compute the argument values. Note that this function will invoke\n  // custom read functions for other fields, if defined. Always returns\n  // immutable data (enforced with Object.freeze in development).\n  readField: ReadFieldFunction;\n\n  // Returns true for non-normalized StoreObjects and non-dangling\n  // References, indicating that readField(name, objOrRef) has a chance of\n  // working. Useful for filtering out dangling references from lists.\n  canRead: CanReadFunction;\n\n  // Instead of just merging objects with { ...existing, ...incoming }, this\n  // helper function can be used to merge objects in a way that respects any\n  // custom merge functions defined for their fields.\n  mergeObjects: MergeObjectsFunction;\n}\n\ntype MergeObjectsFunction = <T extends StoreObject | Reference>(\n  existing: T,\n  incoming: T,\n) => T;\n\nexport type FieldReadFunction<TExisting = any, TReadResult = TExisting> = (\n  // When reading a field, one often needs to know about any existing\n  // value stored for that field. If the field is read before any value\n  // has been written to the cache, this existing parameter will be\n  // undefined, which makes it easy to use a default parameter expression\n  // to supply the initial value. This parameter is positional (rather\n  // than one of the named options) because that makes it possible for the\n  // developer to annotate it with a type, without also having to provide\n  // a whole new type for the options object.\n  existing: SafeReadonly<TExisting> | undefined,\n  options: FieldFunctionOptions,\n) => TReadResult | undefined;\n\nexport type FieldMergeFunction<TExisting = any, TIncoming = TExisting> = (\n  existing: SafeReadonly<TExisting> | undefined,\n  // The incoming parameter needs to be positional as well, for the same\n  // reasons discussed in FieldReadFunction above.\n  incoming: SafeReadonly<TIncoming>,\n  options: FieldFunctionOptions,\n) => SafeReadonly<TExisting>;\n\nexport const defaultDataIdFromObject = (\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n) => {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n         id !== void 0 ? {  id } :\n        _id !== void 0 ? { _id } :\n        void 0;\n    }\n    // If there is no object.id, fall back to object._id.\n    if (id === void 0) id = _id;\n    if (id !== void 0) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n};\n\nconst nullKeyFieldsFn: KeyFieldsFunction = () => void 0;\nconst simpleKeyArgsFn: KeyArgsFunction = (_args, context) => context.fieldName;\n\n// These merge functions can be selected by specifying merge:true or\n// merge:false in a field policy.\nconst mergeTrueFn: FieldMergeFunction<any> =\n  (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);\nconst mergeFalseFn: FieldMergeFunction<any> = (_, incoming) => incoming;\n\nexport type PossibleTypesMap = {\n  [supertype: string]: string[];\n};\n\nexport class Policies {\n  private typePolicies: {\n    [__typename: string]: {\n      keyFn?: KeyFieldsFunction;\n      merge?: FieldMergeFunction<any>;\n      fields: {\n        [fieldName: string]: {\n          keyFn?: KeyArgsFunction;\n          read?: FieldReadFunction<any>;\n          merge?: FieldMergeFunction<any>;\n        };\n      };\n    };\n  } = Object.create(null);\n\n  private toBeAdded: {\n    [__typename: string]: TypePolicy[];\n  } = Object.create(null);\n\n  // Map from subtype names to sets of supertype names. Note that this\n  // representation inverts the structure of possibleTypes (whose keys are\n  // supertypes and whose values are arrays of subtypes) because it tends\n  // to be much more efficient to search upwards than downwards.\n  private supertypeMap = new Map<string, Set<string>>();\n\n  // Any fuzzy subtypes specified by possibleTypes will be converted to\n  // RegExp objects and recorded here. Every key of this map can also be\n  // found in supertypeMap. In many cases this Map will be empty, which\n  // means no fuzzy subtype checking will happen in fragmentMatches.\n  private fuzzySubtypes = new Map<string, RegExp>();\n\n  public readonly cache: InMemoryCache;\n\n  public readonly rootIdsByTypename: Record<string, string> = Object.create(null);\n  public readonly rootTypenamesById: Record<string, string> = Object.create(null);\n\n  public readonly usingPossibleTypes = false;\n\n  constructor(private config: {\n    cache: InMemoryCache;\n    dataIdFromObject?: KeyFieldsFunction;\n    possibleTypes?: PossibleTypesMap;\n    typePolicies?: TypePolicies;\n  }) {\n    this.config = {\n      dataIdFromObject: defaultDataIdFromObject,\n      ...config,\n    };\n\n    this.cache = this.config.cache;\n\n    this.setRootTypename(\"Query\");\n    this.setRootTypename(\"Mutation\");\n    this.setRootTypename(\"Subscription\");\n\n    if (config.possibleTypes) {\n      this.addPossibleTypes(config.possibleTypes);\n    }\n\n    if (config.typePolicies) {\n      this.addTypePolicies(config.typePolicies);\n    }\n  }\n\n  public identify(\n    object: StoreObject,\n    selectionSet?: SelectionSetNode,\n    fragmentMap?: FragmentMap,\n  ): [string?, StoreObject?] {\n    // TODO Use an AliasMap here?\n    const typename = selectionSet && fragmentMap\n      ? getTypenameFromResult(object, selectionSet, fragmentMap)\n      : object.__typename;\n\n    // It should be possible to write root Query fields with\n    // writeFragment, using { __typename: \"Query\", ... } as the data, but\n    // it does not make sense to allow the same identification behavior\n    // for the Mutation and Subscription types, since application code\n    // should never be writing directly to (or reading directly from)\n    // those root objects.\n    if (typename === this.rootTypenamesById.ROOT_QUERY) {\n      return [\"ROOT_QUERY\"];\n    }\n\n    const context: KeyFieldsContext = {\n      typename,\n      selectionSet,\n      fragmentMap,\n    };\n\n    let id: string | undefined;\n\n    const policy = typename && this.getTypePolicy(typename);\n    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;\n    while (keyFn) {\n      const specifierOrId = keyFn(object, context);\n      if (Array.isArray(specifierOrId)) {\n        keyFn = keyFieldsFnFromSpecifier(specifierOrId);\n      } else {\n        id = specifierOrId;\n        break;\n      }\n    }\n\n    id = id && String(id);\n\n    return context.keyObject ? [id, context.keyObject] : [id];\n  }\n\n  public addTypePolicies(typePolicies: TypePolicies) {\n    Object.keys(typePolicies).forEach(typename => {\n      const {\n        queryType,\n        mutationType,\n        subscriptionType,\n        ...incoming\n      } = typePolicies[typename];\n\n      // Though {query,mutation,subscription}Type configurations are rare,\n      // it's important to call setRootTypename as early as possible,\n      // since these configurations should apply consistently for the\n      // entire lifetime of the cache. Also, since only one __typename can\n      // qualify as one of these root types, these three properties cannot\n      // be inherited, unlike the rest of the incoming properties. That\n      // restriction is convenient, because the purpose of this.toBeAdded\n      // is to delay the processing of type/field policies until the first\n      // time they're used, allowing policies to be added in any order as\n      // long as all relevant policies (including policies for supertypes)\n      // have been added by the time a given policy is used for the first\n      // time. In other words, since inheritance doesn't matter for these\n      // properties, there's also no need to delay their processing using\n      // the this.toBeAdded queue.\n      if (queryType) this.setRootTypename(\"Query\", typename);\n      if (mutationType) this.setRootTypename(\"Mutation\", typename);\n      if (subscriptionType) this.setRootTypename(\"Subscription\", typename);\n\n      if (hasOwn.call(this.toBeAdded, typename)) {\n        this.toBeAdded[typename].push(incoming);\n      } else {\n        this.toBeAdded[typename] = [incoming];\n      }\n    });\n  }\n\n  private updateTypePolicy(typename: string, incoming: TypePolicy) {\n    const existing = this.getTypePolicy(typename);\n    const { keyFields, fields } = incoming;\n\n    function setMerge(\n      existing: { merge?: FieldMergeFunction | boolean; },\n      merge?: FieldMergeFunction | boolean,\n    ) {\n      existing.merge =\n        typeof merge === \"function\" ? merge :\n        // Pass merge:true as a shorthand for a merge implementation\n        // that returns options.mergeObjects(existing, incoming).\n        merge === true ? mergeTrueFn :\n        // Pass merge:false to make incoming always replace existing\n        // without any warnings about data clobbering.\n        merge === false ? mergeFalseFn :\n        existing.merge;\n    }\n\n    // Type policies can define merge functions, as an alternative to\n    // using field policies to merge child objects.\n    setMerge(existing, incoming.merge);\n\n    existing.keyFn =\n      // Pass false to disable normalization for this typename.\n      keyFields === false ? nullKeyFieldsFn :\n      // Pass an array of strings to use those fields to compute a\n      // composite ID for objects of this typename.\n      Array.isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) :\n      // Pass a function to take full control over identification.\n      typeof keyFields === \"function\" ? keyFields :\n      // Leave existing.keyFn unchanged if above cases fail.\n      existing.keyFn;\n\n    if (fields) {\n      Object.keys(fields).forEach(fieldName => {\n        const existing = this.getFieldPolicy(typename, fieldName, true)!;\n        const incoming = fields[fieldName];\n\n        if (typeof incoming === \"function\") {\n          existing.read = incoming;\n        } else {\n          const { keyArgs, read, merge } = incoming;\n\n          existing.keyFn =\n            // Pass false to disable argument-based differentiation of\n            // field identities.\n            keyArgs === false ? simpleKeyArgsFn :\n            // Pass an array of strings to use named arguments to\n            // compute a composite identity for the field.\n            Array.isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) :\n            // Pass a function to take full control over field identity.\n            typeof keyArgs === \"function\" ? keyArgs :\n            // Leave existing.keyFn unchanged if above cases fail.\n            existing.keyFn;\n\n          if (typeof read === \"function\") {\n            existing.read = read;\n          }\n\n          setMerge(existing, merge);\n        }\n\n        if (existing.read && existing.merge) {\n          // If we have both a read and a merge function, assume\n          // keyArgs:false, because read and merge together can take\n          // responsibility for interpreting arguments in and out. This\n          // default assumption can always be overridden by specifying\n          // keyArgs explicitly in the FieldPolicy.\n          existing.keyFn = existing.keyFn || simpleKeyArgsFn;\n        }\n      });\n    }\n  }\n\n  private setRootTypename(\n    which: \"Query\" | \"Mutation\" | \"Subscription\",\n    typename: string = which,\n  ) {\n    const rootId = \"ROOT_\" + which.toUpperCase();\n    const old = this.rootTypenamesById[rootId];\n    if (typename !== old) {\n      invariant(!old || old === which, `Cannot change root ${which} __typename more than once`);\n      // First, delete any old __typename associated with this rootId from\n      // rootIdsByTypename.\n      if (old) delete this.rootIdsByTypename[old];\n      // Now make this the only __typename that maps to this rootId.\n      this.rootIdsByTypename[typename] = rootId;\n      // Finally, update the __typename associated with this rootId.\n      this.rootTypenamesById[rootId] = typename;\n    }\n  }\n\n  public addPossibleTypes(possibleTypes: PossibleTypesMap) {\n    (this.usingPossibleTypes as boolean) = true;\n    Object.keys(possibleTypes).forEach(supertype => {\n      // Make sure all types have an entry in this.supertypeMap, even if\n      // their supertype set is empty, so we can return false immediately\n      // from policies.fragmentMatches for unknown supertypes.\n      this.getSupertypeSet(supertype, true);\n\n      possibleTypes[supertype].forEach(subtype => {\n        this.getSupertypeSet(subtype, true)!.add(supertype);\n        const match = subtype.match(TypeOrFieldNameRegExp);\n        if (!match || match[0] !== subtype) {\n          // TODO Don't interpret just any invalid typename as a RegExp.\n          this.fuzzySubtypes.set(subtype, new RegExp(subtype));\n        }\n      });\n    });\n  }\n\n  private getTypePolicy(typename: string): Policies[\"typePolicies\"][string] {\n    if (!hasOwn.call(this.typePolicies, typename)) {\n      const policy: Policies[\"typePolicies\"][string] =\n        this.typePolicies[typename] = Object.create(null);\n      policy.fields = Object.create(null);\n\n      // When the TypePolicy for typename is first accessed, instead of\n      // starting with an empty policy object, inherit any properties or\n      // fields from the type policies of the supertypes of typename.\n      //\n      // Any properties or fields defined explicitly within the TypePolicy\n      // for typename will take precedence, and if there are multiple\n      // supertypes, the properties of policies whose types were added\n      // later via addPossibleTypes will take precedence over those of\n      // earlier supertypes. TODO Perhaps we should warn about these\n      // conflicts in development, and recommend defining the property\n      // explicitly in the subtype policy?\n      //\n      // Field policy inheritance is atomic/shallow: you can't inherit a\n      // field policy and then override just its read function, since read\n      // and merge functions often need to cooperate, so changing only one\n      // of them would be a recipe for inconsistency.\n      //\n      // Once the TypePolicy for typename has been accessed, its\n      // properties can still be updated directly using addTypePolicies,\n      // but future changes to supertype policies will not be reflected in\n      // this policy, because this code runs at most once per typename.\n      const supertypes = this.supertypeMap.get(typename);\n      if (supertypes && supertypes.size) {\n        supertypes.forEach(supertype => {\n          const { fields, ...rest } = this.getTypePolicy(supertype);\n          Object.assign(policy, rest);\n          Object.assign(policy.fields, fields);\n        });\n      }\n    }\n\n    const inbox = this.toBeAdded[typename];\n    if (inbox && inbox.length) {\n      this.updateTypePolicy(typename, compact(...inbox.splice(0)));\n    }\n\n    return this.typePolicies[typename];\n  }\n\n  private getFieldPolicy(\n    typename: string | undefined,\n    fieldName: string,\n    createIfMissing: boolean,\n  ): {\n    keyFn?: KeyArgsFunction;\n    read?: FieldReadFunction<any>;\n    merge?: FieldMergeFunction<any>;\n  } | undefined {\n    if (typename) {\n      const fieldPolicies = this.getTypePolicy(typename).fields;\n      return fieldPolicies[fieldName] || (\n        createIfMissing && (fieldPolicies[fieldName] = Object.create(null)));\n    }\n  }\n\n  private getSupertypeSet(\n    subtype: string,\n    createIfMissing: boolean,\n  ): Set<string> | undefined {\n    let supertypeSet = this.supertypeMap.get(subtype);\n    if (!supertypeSet && createIfMissing) {\n      this.supertypeMap.set(subtype, supertypeSet = new Set<string>());\n    }\n    return supertypeSet;\n  }\n\n  public fragmentMatches(\n    fragment: InlineFragmentNode | FragmentDefinitionNode,\n    typename: string | undefined,\n    result?: Record<string, any>,\n    variables?: Record<string, any>,\n  ): boolean {\n    if (!fragment.typeCondition) return true;\n\n    // If the fragment has a type condition but the object we're matching\n    // against does not have a __typename, the fragment cannot match.\n    if (!typename) return false;\n\n    const supertype = fragment.typeCondition.name.value;\n    // Common case: fragment type condition and __typename are the same.\n    if (typename === supertype) return true;\n\n    if (this.usingPossibleTypes &&\n        this.supertypeMap.has(supertype)) {\n      const typenameSupertypeSet = this.getSupertypeSet(typename, true)!;\n      const workQueue = [typenameSupertypeSet];\n      const maybeEnqueue = (subtype: string) => {\n        const supertypeSet = this.getSupertypeSet(subtype, false);\n        if (supertypeSet &&\n            supertypeSet.size &&\n            workQueue.indexOf(supertypeSet) < 0) {\n          workQueue.push(supertypeSet);\n        }\n      };\n\n      // We need to check fuzzy subtypes only if we encountered fuzzy\n      // subtype strings in addPossibleTypes, and only while writing to\n      // the cache, since that's when selectionSetMatchesResult gives a\n      // strong signal of fragment matching. The StoreReader class calls\n      // policies.fragmentMatches without passing a result object, so\n      // needToCheckFuzzySubtypes is always false while reading.\n      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);\n      let checkingFuzzySubtypes = false;\n\n      // It's important to keep evaluating workQueue.length each time through\n      // the loop, because the queue can grow while we're iterating over it.\n      for (let i = 0; i < workQueue.length; ++i) {\n        const supertypeSet = workQueue[i];\n\n        if (supertypeSet.has(supertype)) {\n          if (!typenameSupertypeSet.has(supertype)) {\n            if (checkingFuzzySubtypes) {\n              invariant.warn(`Inferring subtype ${typename} of supertype ${supertype}`);\n            }\n            // Record positive results for faster future lookup.\n            // Unfortunately, we cannot safely cache negative results,\n            // because new possibleTypes data could always be added to the\n            // Policies class.\n            typenameSupertypeSet.add(supertype);\n          }\n          return true;\n        }\n\n        supertypeSet.forEach(maybeEnqueue);\n\n        if (needToCheckFuzzySubtypes &&\n            // Start checking fuzzy subtypes only after exhausting all\n            // non-fuzzy subtypes (after the final iteration of the loop).\n            i === workQueue.length - 1 &&\n            // We could wait to compare fragment.selectionSet to result\n            // after we verify the supertype, but this check is often less\n            // expensive than that search, and we will have to do the\n            // comparison anyway whenever we find a potential match.\n            selectionSetMatchesResult(fragment.selectionSet, result!, variables)) {\n          // We don't always need to check fuzzy subtypes (if no result\n          // was provided, or !this.fuzzySubtypes.size), but, when we do,\n          // we only want to check them once.\n          needToCheckFuzzySubtypes = false;\n          checkingFuzzySubtypes = true;\n\n          // If we find any fuzzy subtypes that match typename, extend the\n          // workQueue to search through the supertypes of those fuzzy\n          // subtypes. Otherwise the for-loop will terminate and we'll\n          // return false below.\n          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {\n            const match = typename.match(regExp);\n            if (match && match[0] === typename) {\n              maybeEnqueue(fuzzyString);\n            }\n          });\n        }\n      }\n    }\n\n    return false;\n  }\n\n  public hasKeyArgs(typename: string | undefined, fieldName: string) {\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    return !!(policy && policy.keyFn);\n  }\n\n  public getStoreFieldName(fieldSpec: FieldSpecifier): string {\n    const { typename, fieldName } = fieldSpec;\n    const policy = this.getFieldPolicy(typename, fieldName, false);\n    let storeFieldName: string | undefined;\n\n    let keyFn = policy && policy.keyFn;\n    if (keyFn && typename) {\n      const context: Parameters<KeyArgsFunction>[1] = {\n        typename,\n        fieldName,\n        field: fieldSpec.field || null,\n        variables: fieldSpec.variables,\n      };\n      const args = argsFromFieldSpecifier(fieldSpec);\n      while (keyFn) {\n        const specifierOrString = keyFn(args, context);\n        if (Array.isArray(specifierOrString)) {\n          keyFn = keyArgsFnFromSpecifier(specifierOrString);\n        } else {\n          // If the custom keyFn returns a falsy value, fall back to\n          // fieldName instead.\n          storeFieldName = specifierOrString || fieldName;\n          break;\n        }\n      }\n    }\n\n    if (storeFieldName === void 0) {\n      storeFieldName = fieldSpec.field\n        ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables)\n        : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));\n    }\n\n    // Make sure custom field names start with the actual field.name.value\n    // of the field, so we can always figure out which properties of a\n    // StoreObject correspond to which original field names.\n    return fieldName === fieldNameFromStoreName(storeFieldName)\n      ? storeFieldName\n      : fieldName + \":\" + storeFieldName;\n  }\n\n  public readField<V = StoreValue>(\n    options: ReadFieldOptions,\n    context: ReadMergeModifyContext,\n  ): SafeReadonly<V> | undefined {\n    const objectOrReference = options.from;\n    if (!objectOrReference) return;\n\n    const nameOrField = options.field || options.fieldName;\n    if (!nameOrField) return;\n\n    if (options.typename === void 0) {\n      const typename = context.store.getFieldValue<string>(objectOrReference, \"__typename\");\n      if (typename) options.typename = typename;\n    }\n\n    const storeFieldName = this.getStoreFieldName(options);\n    const fieldName = fieldNameFromStoreName(storeFieldName);\n    const existing = context.store.getFieldValue<V>(objectOrReference, storeFieldName);\n    const policy = this.getFieldPolicy(options.typename, fieldName, false);\n    const read = policy && policy.read;\n\n    if (read) {\n      const readOptions = makeFieldFunctionOptions(\n        this,\n        objectOrReference,\n        options,\n        context,\n        context.store.getStorage(\n          isReference(objectOrReference)\n            ? objectOrReference.__ref\n            : objectOrReference,\n          storeFieldName,\n        ),\n      );\n\n      // Call read(existing, readOptions) with cacheSlot holding this.cache.\n      return cacheSlot.withValue(\n        this.cache,\n        read,\n        [existing, readOptions],\n      ) as SafeReadonly<V>;\n    }\n\n    return existing;\n  }\n\n  public getMergeFunction(\n    parentTypename: string | undefined,\n    fieldName: string,\n    childTypename: string | undefined,\n  ): FieldMergeFunction | undefined {\n    let policy:\n      | Policies[\"typePolicies\"][string]\n      | Policies[\"typePolicies\"][string][\"fields\"][string]\n      | undefined =\n      this.getFieldPolicy(parentTypename, fieldName, false);\n    let merge = policy && policy.merge;\n    if (!merge && childTypename) {\n      policy = this.getTypePolicy(childTypename);\n      merge = policy && policy.merge;\n    }\n    return merge;\n  }\n\n  public runMergeFunction(\n    existing: StoreValue,\n    incoming: StoreValue,\n    { field, typename, merge }: MergeInfo,\n    context: ReadMergeModifyContext,\n    storage?: StorageType,\n  ) {\n    if (merge === mergeTrueFn) {\n      // Instead of going to the trouble of creating a full\n      // FieldFunctionOptions object and calling mergeTrueFn, we can\n      // simply call mergeObjects, as mergeTrueFn would.\n      return makeMergeObjectsFunction(\n        context.store.getFieldValue\n      )(existing as StoreObject,\n        incoming as StoreObject);\n    }\n\n    if (merge === mergeFalseFn) {\n      // Likewise for mergeFalseFn, whose implementation is even simpler.\n      return incoming;\n    }\n\n    return merge(existing, incoming, makeFieldFunctionOptions(\n      this,\n      // Unlike options.readField for read functions, we do not fall\n      // back to the current object if no foreignObjOrRef is provided,\n      // because it's not clear what the current object should be for\n      // merge functions: the (possibly undefined) existing object, or\n      // the incoming object? If you think your merge function needs\n      // to read sibling fields in order to produce a new value for\n      // the current field, you might want to rethink your strategy,\n      // because that's a recipe for making merge behavior sensitive\n      // to the order in which fields are written into the cache.\n      // However, readField(name, ref) is useful for merge functions\n      // that need to deduplicate child objects and references.\n      void 0,\n      { typename,\n        fieldName: field.name.value,\n        field,\n        variables: context.variables },\n      context,\n      storage || Object.create(null),\n    ));\n  }\n}\n\nfunction makeFieldFunctionOptions(\n  policies: Policies,\n  objectOrReference: StoreObject | Reference | undefined,\n  fieldSpec: FieldSpecifier,\n  context: ReadMergeModifyContext,\n  storage: StorageType,\n): FieldFunctionOptions {\n  const storeFieldName = policies.getStoreFieldName(fieldSpec);\n  const fieldName = fieldNameFromStoreName(storeFieldName);\n  const variables = fieldSpec.variables || context.variables;\n  const { getFieldValue, toReference, canRead } = context.store;\n\n  return {\n    args: argsFromFieldSpecifier(fieldSpec),\n    field: fieldSpec.field || null,\n    fieldName,\n    storeFieldName,\n    variables,\n    isReference,\n    toReference,\n    storage,\n    cache: policies.cache,\n    canRead,\n\n    readField<T>(\n      fieldNameOrOptions: string | ReadFieldOptions,\n      from?: StoreObject | Reference,\n    ) {\n      const options: ReadFieldOptions =\n        typeof fieldNameOrOptions === \"string\" ? {\n          fieldName: fieldNameOrOptions,\n          from,\n        } : { ...fieldNameOrOptions };\n\n      if (void 0 === options.from) {\n        options.from = objectOrReference;\n      }\n\n      if (void 0 === options.variables) {\n        options.variables = variables;\n      }\n\n      return policies.readField<T>(options, context);\n    },\n\n    mergeObjects: makeMergeObjectsFunction(getFieldValue),\n  };\n}\n\nfunction makeMergeObjectsFunction(\n  getFieldValue: FieldValueGetter,\n): MergeObjectsFunction {\n  return function mergeObjects(existing, incoming) {\n    if (Array.isArray(existing) || Array.isArray(incoming)) {\n      throw new InvariantError(\"Cannot automatically merge arrays\");\n    }\n\n    // These dynamic checks are necessary because the parameters of a\n    // custom merge function can easily have the any type, so the type\n    // system cannot always enforce the StoreObject | Reference parameter\n    // types of options.mergeObjects.\n    if (existing && typeof existing === \"object\" &&\n        incoming && typeof incoming === \"object\") {\n      const eType = getFieldValue(existing, \"__typename\");\n      const iType = getFieldValue(incoming, \"__typename\");\n      const typesDiffer = eType && iType && eType !== iType;\n\n      if (typesDiffer ||\n          !storeValueIsStoreObject(existing) ||\n          !storeValueIsStoreObject(incoming)) {\n        return incoming;\n      }\n\n      return { ...existing, ...incoming };\n    }\n\n    return incoming;\n  };\n}\n\nfunction keyArgsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyArgsFunction {\n  return (args, context) => {\n    return args ? `${context.fieldName}:${\n      JSON.stringify(computeKeyObject(args, specifier, false))\n    }` : context.fieldName;\n  };\n}\n\nfunction keyFieldsFnFromSpecifier(\n  specifier: KeySpecifier,\n): KeyFieldsFunction {\n  const trie = new KeyTrie<{\n    aliasMap?: AliasMap;\n  }>(canUseWeakMap);\n\n  return (object, context) => {\n    let aliasMap: AliasMap | undefined;\n    if (context.selectionSet && context.fragmentMap) {\n      const info = trie.lookupArray([\n        context.selectionSet,\n        context.fragmentMap,\n      ]);\n      aliasMap = info.aliasMap || (\n        info.aliasMap = makeAliasMap(context.selectionSet, context.fragmentMap)\n      );\n    }\n\n    const keyObject = context.keyObject =\n      computeKeyObject(object, specifier, true, aliasMap);\n\n    return `${context.typename}:${JSON.stringify(keyObject)}`;\n  };\n}\n\ntype AliasMap = {\n  // Map from store key to corresponding response key. Undefined when there are\n  // no aliased fields in this selection set.\n  aliases?: Record<string, string>;\n  // Map from store key to AliasMap correponding to a child selection set.\n  // Undefined when there are no child selection sets.\n  subsets?: Record<string, AliasMap>;\n};\n\nfunction makeAliasMap(\n  selectionSet: SelectionSetNode,\n  fragmentMap: FragmentMap,\n): AliasMap {\n  let map: AliasMap = Object.create(null);\n  // TODO Cache this work, perhaps by storing selectionSet._aliasMap?\n  const workQueue = new Set([selectionSet]);\n  workQueue.forEach(selectionSet => {\n    selectionSet.selections.forEach(selection => {\n      if (isField(selection)) {\n        if (selection.alias) {\n          const responseKey = selection.alias.value;\n          const storeKey = selection.name.value;\n          if (storeKey !== responseKey) {\n            const aliases = map.aliases || (map.aliases = Object.create(null));\n            aliases[storeKey] = responseKey;\n          }\n        }\n        if (selection.selectionSet) {\n          const subsets = map.subsets || (map.subsets = Object.create(null));\n          subsets[selection.name.value] =\n            makeAliasMap(selection.selectionSet, fragmentMap);\n        }\n      } else {\n        const fragment = getFragmentFromSelection(selection, fragmentMap);\n        if (fragment) {\n          workQueue.add(fragment.selectionSet);\n        }\n      }\n    });\n  });\n  return map;\n}\n\nfunction computeKeyObject(\n  response: Record<string, any>,\n  specifier: KeySpecifier,\n  strict: boolean,\n  aliasMap?: AliasMap,\n): Record<string, any> {\n  // The order of adding properties to keyObj affects its JSON serialization,\n  // so we are careful to build keyObj in the order of keys given in\n  // specifier.\n  const keyObj = Object.create(null);\n  let prevKey: string | undefined;\n  specifier.forEach(s => {\n    if (Array.isArray(s)) {\n      if (typeof prevKey === \"string\") {\n        const subsets = aliasMap && aliasMap.subsets;\n        const subset = subsets && subsets[prevKey];\n        keyObj[prevKey] = computeKeyObject(response[prevKey], s, strict, subset);\n      }\n    } else {\n      const aliases = aliasMap && aliasMap.aliases;\n      const responseName = aliases && aliases[s] || s;\n      if (hasOwn.call(response, responseName)) {\n        keyObj[prevKey = s] = response[responseName];\n      } else {\n        invariant(!strict, `Missing field '${responseName}' while computing key fields`);\n        prevKey = void 0;\n      }\n    }\n  });\n  return keyObj;\n}\n"]},"metadata":{},"sourceType":"module"}