{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\nimport { execute } from \"../link/core/index.js\";\nimport { getDefaultValues, getOperationDefinition, getOperationName, hasClientExports, graphQLResultHasError, removeConnectionDirectiveFromDocument, canUseWeakMap, Observable, asyncMap, isNonEmptyArray, Concast } from \"../utilities/index.js\";\nimport { ApolloError, isApolloError } from \"../errors/index.js\";\nimport { ObservableQuery } from \"./ObservableQuery.js\";\nimport { NetworkStatus, isNetworkRequestInFlight } from \"./networkStatus.js\";\nimport { LocalState } from \"./LocalState.js\";\nimport { QueryInfo, shouldWriteResult } from \"./QueryInfo.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar QueryManager = function () {\n  function QueryManager(_a) {\n    var cache = _a.cache,\n        link = _a.link,\n        _b = _a.queryDeduplication,\n        queryDeduplication = _b === void 0 ? false : _b,\n        onBroadcast = _a.onBroadcast,\n        _c = _a.ssrMode,\n        ssrMode = _c === void 0 ? false : _c,\n        _d = _a.clientAwareness,\n        clientAwareness = _d === void 0 ? {} : _d,\n        localState = _a.localState,\n        assumeImmutableResults = _a.assumeImmutableResults;\n    this.clientAwareness = {};\n    this.queries = new Map();\n    this.fetchCancelFns = new Map();\n    this.transformCache = new (canUseWeakMap ? WeakMap : Map)();\n    this.queryIdCounter = 1;\n    this.requestIdCounter = 1;\n    this.mutationIdCounter = 1;\n    this.inFlightLinkObservables = new Map();\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({\n      cache: cache\n    });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n\n    if (this.onBroadcast = onBroadcast) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  QueryManager.prototype.stop = function () {\n    var _this = this;\n\n    this.queries.forEach(function (_info, queryId) {\n      _this.stopQueryNoBroadcast(queryId);\n    });\n    this.cancelPendingFetches(process.env.NODE_ENV === \"production\" ? new InvariantError(12) : new InvariantError('QueryManager stopped while query was in flight'));\n  };\n\n  QueryManager.prototype.cancelPendingFetches = function (error) {\n    this.fetchCancelFns.forEach(function (cancel) {\n      return cancel(error);\n    });\n    this.fetchCancelFns.clear();\n  };\n\n  QueryManager.prototype.mutate = function (_a) {\n    var mutation = _a.mutation,\n        variables = _a.variables,\n        optimisticResponse = _a.optimisticResponse,\n        updateQueries = _a.updateQueries,\n        _b = _a.refetchQueries,\n        refetchQueries = _b === void 0 ? [] : _b,\n        _c = _a.awaitRefetchQueries,\n        awaitRefetchQueries = _c === void 0 ? false : _c,\n        updateWithProxyFn = _a.update,\n        _d = _a.errorPolicy,\n        errorPolicy = _d === void 0 ? 'none' : _d,\n        fetchPolicy = _a.fetchPolicy,\n        _e = _a.context,\n        context = _e === void 0 ? {} : _e;\n    return __awaiter(this, void 0, void 0, function () {\n      var mutationId, mutationStoreValue, self;\n      return __generator(this, function (_f) {\n        switch (_f.label) {\n          case 0:\n            process.env.NODE_ENV === \"production\" ? invariant(mutation, 13) : invariant(mutation, 'mutation option is required. You must specify your GraphQL document in the mutation option.');\n            process.env.NODE_ENV === \"production\" ? invariant(!fetchPolicy || fetchPolicy === 'no-cache', 14) : invariant(!fetchPolicy || fetchPolicy === 'no-cache', \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\");\n            mutationId = this.generateMutationId();\n            mutation = this.transform(mutation).document;\n            variables = this.getVariables(mutation, variables);\n            if (!this.transform(mutation).hasClientExports) return [3, 2];\n            return [4, this.localState.addExportedVariables(mutation, variables, context)];\n\n          case 1:\n            variables = _f.sent();\n            _f.label = 2;\n\n          case 2:\n            mutationStoreValue = this.mutationStore && (this.mutationStore[mutationId] = {\n              mutation: mutation,\n              variables: variables,\n              loading: true,\n              error: null\n            });\n\n            if (optimisticResponse) {\n              this.markMutationOptimistic(optimisticResponse, {\n                mutationId: mutationId,\n                document: mutation,\n                variables: variables,\n                errorPolicy: errorPolicy,\n                updateQueries: updateQueries,\n                update: updateWithProxyFn\n              });\n            }\n\n            this.broadcastQueries();\n            self = this;\n            return [2, new Promise(function (resolve, reject) {\n              var storeResult;\n              var error;\n              self.getObservableFromLink(mutation, __assign(__assign({}, context), {\n                optimisticResponse: optimisticResponse\n              }), variables, false).subscribe({\n                next: function (result) {\n                  if (graphQLResultHasError(result) && errorPolicy === 'none') {\n                    error = new ApolloError({\n                      graphQLErrors: result.errors\n                    });\n                    return;\n                  }\n\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = null;\n                  }\n\n                  if (fetchPolicy !== 'no-cache') {\n                    try {\n                      self.markMutationResult({\n                        mutationId: mutationId,\n                        result: result,\n                        document: mutation,\n                        variables: variables,\n                        errorPolicy: errorPolicy,\n                        updateQueries: updateQueries,\n                        update: updateWithProxyFn\n                      });\n                    } catch (e) {\n                      error = new ApolloError({\n                        networkError: e\n                      });\n                      return;\n                    }\n                  }\n\n                  storeResult = result;\n                },\n                error: function (err) {\n                  if (mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = err;\n                  }\n\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n\n                  self.broadcastQueries();\n                  reject(new ApolloError({\n                    networkError: err\n                  }));\n                },\n                complete: function () {\n                  if (error && mutationStoreValue) {\n                    mutationStoreValue.loading = false;\n                    mutationStoreValue.error = error;\n                  }\n\n                  if (optimisticResponse) {\n                    self.cache.removeOptimistic(mutationId);\n                  }\n\n                  self.broadcastQueries();\n\n                  if (error) {\n                    reject(error);\n                    return;\n                  }\n\n                  if (typeof refetchQueries === 'function') {\n                    refetchQueries = refetchQueries(storeResult);\n                  }\n\n                  var refetchQueryPromises = [];\n\n                  if (isNonEmptyArray(refetchQueries)) {\n                    refetchQueries.forEach(function (refetchQuery) {\n                      if (typeof refetchQuery === 'string') {\n                        self.queries.forEach(function (_a) {\n                          var observableQuery = _a.observableQuery;\n\n                          if (observableQuery && observableQuery.queryName === refetchQuery) {\n                            refetchQueryPromises.push(observableQuery.refetch());\n                          }\n                        });\n                      } else {\n                        var queryOptions = {\n                          query: refetchQuery.query,\n                          variables: refetchQuery.variables,\n                          fetchPolicy: 'network-only'\n                        };\n\n                        if (refetchQuery.context) {\n                          queryOptions.context = refetchQuery.context;\n                        }\n\n                        refetchQueryPromises.push(self.query(queryOptions));\n                      }\n                    });\n                  }\n\n                  Promise.all(awaitRefetchQueries ? refetchQueryPromises : []).then(function () {\n                    if (errorPolicy === 'ignore' && storeResult && graphQLResultHasError(storeResult)) {\n                      delete storeResult.errors;\n                    }\n\n                    resolve(storeResult);\n                  }, reject);\n                }\n              });\n            })];\n        }\n      });\n    });\n  };\n\n  QueryManager.prototype.markMutationResult = function (mutation, cache) {\n    var _this = this;\n\n    if (cache === void 0) {\n      cache = this.cache;\n    }\n\n    if (shouldWriteResult(mutation.result, mutation.errorPolicy)) {\n      var cacheWrites_1 = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables\n      }];\n      var updateQueries_1 = mutation.updateQueries;\n\n      if (updateQueries_1) {\n        this.queries.forEach(function (_a, queryId) {\n          var observableQuery = _a.observableQuery;\n          var queryName = observableQuery && observableQuery.queryName;\n\n          if (!queryName || !hasOwnProperty.call(updateQueries_1, queryName)) {\n            return;\n          }\n\n          var updater = updateQueries_1[queryName];\n\n          var _b = _this.queries.get(queryId),\n              document = _b.document,\n              variables = _b.variables;\n\n          var _c = cache.diff({\n            query: document,\n            variables: variables,\n            returnPartialData: true,\n            optimistic: false\n          }),\n              currentQueryResult = _c.result,\n              complete = _c.complete;\n\n          if (complete && currentQueryResult) {\n            var nextQueryResult = updater(currentQueryResult, {\n              mutationResult: mutation.result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables\n            });\n\n            if (nextQueryResult) {\n              cacheWrites_1.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document,\n                variables: variables\n              });\n            }\n          }\n        });\n      }\n\n      cache.performTransaction(function (c) {\n        cacheWrites_1.forEach(function (write) {\n          return c.write(write);\n        });\n        var update = mutation.update;\n\n        if (update) {\n          update(c, mutation.result);\n        }\n      }, null);\n    }\n  };\n\n  QueryManager.prototype.markMutationOptimistic = function (optimisticResponse, mutation) {\n    var _this = this;\n\n    var data = typeof optimisticResponse === \"function\" ? optimisticResponse(mutation.variables) : optimisticResponse;\n    return this.cache.recordOptimisticTransaction(function (cache) {\n      try {\n        _this.markMutationResult(__assign(__assign({}, mutation), {\n          result: {\n            data: data\n          }\n        }), cache);\n      } catch (error) {\n        process.env.NODE_ENV === \"production\" || invariant.error(error);\n      }\n    }, mutation.mutationId);\n  };\n\n  QueryManager.prototype.fetchQuery = function (queryId, options, networkStatus) {\n    return this.fetchQueryObservable(queryId, options, networkStatus).promise;\n  };\n\n  QueryManager.prototype.getQueryStore = function () {\n    var store = Object.create(null);\n    this.queries.forEach(function (info, queryId) {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors\n      };\n    });\n    return store;\n  };\n\n  QueryManager.prototype.resetErrors = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  };\n\n  QueryManager.prototype.transform = function (document) {\n    var transformCache = this.transformCache;\n\n    if (!transformCache.has(document)) {\n      var transformed = this.cache.transformDocument(document);\n      var forLink = removeConnectionDirectiveFromDocument(this.cache.transformForLink(transformed));\n      var clientQuery = this.localState.clientQuery(transformed);\n      var serverQuery = forLink && this.localState.serverQuery(forLink);\n      var cacheEntry_1 = {\n        document: transformed,\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery: clientQuery,\n        serverQuery: serverQuery,\n        defaultVars: getDefaultValues(getOperationDefinition(transformed))\n      };\n\n      var add = function (doc) {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry_1);\n        }\n      };\n\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document);\n  };\n\n  QueryManager.prototype.getVariables = function (document, variables) {\n    return __assign(__assign({}, this.transform(document).defaultVars), variables);\n  };\n\n  QueryManager.prototype.watchQuery = function (options) {\n    options = __assign(__assign({}, options), {\n      variables: this.getVariables(options.query, options.variables)\n    });\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    var queryInfo = new QueryInfo(this.cache);\n    var observable = new ObservableQuery({\n      queryManager: this,\n      queryInfo: queryInfo,\n      options: options\n    });\n    this.queries.set(observable.queryId, queryInfo);\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables\n    });\n    return observable;\n  };\n\n  QueryManager.prototype.query = function (options) {\n    var _this = this;\n\n    process.env.NODE_ENV === \"production\" ? invariant(options.query, 15) : invariant(options.query, 'query option is required. You must specify your GraphQL document ' + 'in the query option.');\n    process.env.NODE_ENV === \"production\" ? invariant(options.query.kind === 'Document', 16) : invariant(options.query.kind === 'Document', 'You must wrap the query string in a \"gql\" tag.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.returnPartialData, 17) : invariant(!options.returnPartialData, 'returnPartialData option only supported on watchQuery.');\n    process.env.NODE_ENV === \"production\" ? invariant(!options.pollInterval, 18) : invariant(!options.pollInterval, 'pollInterval option only supported on watchQuery.');\n    var queryId = this.generateQueryId();\n    return this.fetchQuery(queryId, options).finally(function () {\n      return _this.stopQuery(queryId);\n    });\n  };\n\n  QueryManager.prototype.generateQueryId = function () {\n    return String(this.queryIdCounter++);\n  };\n\n  QueryManager.prototype.generateRequestId = function () {\n    return this.requestIdCounter++;\n  };\n\n  QueryManager.prototype.generateMutationId = function () {\n    return String(this.mutationIdCounter++);\n  };\n\n  QueryManager.prototype.stopQueryInStore = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryInStoreNoBroadcast = function (queryId) {\n    var queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  };\n\n  QueryManager.prototype.clearStore = function () {\n    this.cancelPendingFetches(process.env.NODE_ENV === \"production\" ? new InvariantError(19) : new InvariantError('Store reset while query was in flight (not completed in link chain)'));\n    this.queries.forEach(function (queryInfo) {\n      if (queryInfo.observableQuery) {\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    return this.cache.reset();\n  };\n\n  QueryManager.prototype.resetStore = function () {\n    var _this = this;\n\n    return this.clearStore().then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n\n  QueryManager.prototype.reFetchObservableQueries = function (includeStandby) {\n    var _this = this;\n\n    if (includeStandby === void 0) {\n      includeStandby = false;\n    }\n\n    var observableQueryPromises = [];\n    this.queries.forEach(function (_a, queryId) {\n      var observableQuery = _a.observableQuery;\n\n      if (observableQuery && observableQuery.hasObservers()) {\n        var fetchPolicy = observableQuery.options.fetchPolicy;\n        observableQuery.resetLastResults();\n\n        if (fetchPolicy !== 'cache-only' && (includeStandby || fetchPolicy !== 'standby')) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        _this.getQuery(queryId).setDiff(null);\n      }\n    });\n    this.broadcastQueries();\n    return Promise.all(observableQueryPromises);\n  };\n\n  QueryManager.prototype.setObservableQuery = function (observableQuery) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  };\n\n  QueryManager.prototype.startGraphQLSubscription = function (_a) {\n    var _this = this;\n\n    var query = _a.query,\n        fetchPolicy = _a.fetchPolicy,\n        errorPolicy = _a.errorPolicy,\n        variables = _a.variables,\n        _b = _a.context,\n        context = _b === void 0 ? {} : _b;\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    var makeObservable = function (variables) {\n      return _this.getObservableFromLink(query, context, variables, false).map(function (result) {\n        if (fetchPolicy !== 'no-cache') {\n          if (shouldWriteResult(result, errorPolicy)) {\n            _this.cache.write({\n              query: query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables\n            });\n          }\n\n          _this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors\n          });\n        }\n\n        return result;\n      });\n    };\n\n    if (this.transform(query).hasClientExports) {\n      var observablePromise_1 = this.localState.addExportedVariables(query, variables, context).then(makeObservable);\n      return new Observable(function (observer) {\n        var sub = null;\n        observablePromise_1.then(function (observable) {\n          return sub = observable.subscribe(observer);\n        }, observer.error);\n        return function () {\n          return sub && sub.unsubscribe();\n        };\n      });\n    }\n\n    return makeObservable(variables);\n  };\n\n  QueryManager.prototype.stopQuery = function (queryId) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  };\n\n  QueryManager.prototype.stopQueryNoBroadcast = function (queryId) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  };\n\n  QueryManager.prototype.removeQuery = function (queryId) {\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  };\n\n  QueryManager.prototype.broadcastQueries = function () {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(function (info) {\n      return info.notify();\n    });\n  };\n\n  QueryManager.prototype.getLocalState = function () {\n    return this.localState;\n  };\n\n  QueryManager.prototype.getObservableFromLink = function (query, context, variables, deduplication) {\n    var _this = this;\n\n    var _a;\n\n    if (deduplication === void 0) {\n      deduplication = (_a = context === null || context === void 0 ? void 0 : context.queryDeduplication) !== null && _a !== void 0 ? _a : this.queryDeduplication;\n    }\n\n    var observable;\n    var serverQuery = this.transform(query).serverQuery;\n\n    if (serverQuery) {\n      var _b = this,\n          inFlightLinkObservables_1 = _b.inFlightLinkObservables,\n          link = _b.link;\n\n      var operation = {\n        query: serverQuery,\n        variables: variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext(__assign(__assign({}, context), {\n          forceFetch: !deduplication\n        }))\n      };\n      context = operation.context;\n\n      if (deduplication) {\n        var byVariables_1 = inFlightLinkObservables_1.get(serverQuery) || new Map();\n        inFlightLinkObservables_1.set(serverQuery, byVariables_1);\n        var varJson_1 = JSON.stringify(variables);\n        observable = byVariables_1.get(varJson_1);\n\n        if (!observable) {\n          var concast = new Concast([execute(link, operation)]);\n          byVariables_1.set(varJson_1, observable = concast);\n          concast.cleanup(function () {\n            if (byVariables_1.delete(varJson_1) && byVariables_1.size < 1) {\n              inFlightLinkObservables_1.delete(serverQuery);\n            }\n          });\n        }\n      } else {\n        observable = new Concast([execute(link, operation)]);\n      }\n    } else {\n      observable = new Concast([Observable.of({\n        data: {}\n      })]);\n      context = this.prepareContext(context);\n    }\n\n    var clientQuery = this.transform(query).clientQuery;\n\n    if (clientQuery) {\n      observable = asyncMap(observable, function (result) {\n        return _this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context: context,\n          variables: variables\n        });\n      });\n    }\n\n    return observable;\n  };\n\n  QueryManager.prototype.getResultsFromLink = function (queryInfo, allowCacheWrite, options) {\n    var lastRequestId = queryInfo.lastRequestId;\n    return asyncMap(this.getObservableFromLink(queryInfo.document, options.context, options.variables), function (result) {\n      var hasErrors = isNonEmptyArray(result.errors);\n\n      if (lastRequestId >= queryInfo.lastRequestId) {\n        if (hasErrors && options.errorPolicy === \"none\") {\n          throw queryInfo.markError(new ApolloError({\n            graphQLErrors: result.errors\n          }));\n        }\n\n        queryInfo.markResult(result, options, allowCacheWrite);\n        queryInfo.markReady();\n      }\n\n      var aqr = {\n        data: result.data,\n        loading: false,\n        networkStatus: queryInfo.networkStatus || NetworkStatus.ready\n      };\n\n      if (hasErrors && options.errorPolicy !== \"ignore\") {\n        aqr.errors = result.errors;\n      }\n\n      return aqr;\n    }, function (networkError) {\n      var error = isApolloError(networkError) ? networkError : new ApolloError({\n        networkError: networkError\n      });\n\n      if (lastRequestId >= queryInfo.lastRequestId) {\n        queryInfo.markError(error);\n      }\n\n      throw error;\n    });\n  };\n\n  QueryManager.prototype.fetchQueryObservable = function (queryId, options, networkStatus) {\n    var _this = this;\n\n    if (networkStatus === void 0) {\n      networkStatus = NetworkStatus.loading;\n    }\n\n    var query = this.transform(options.query).document;\n    var variables = this.getVariables(query, options.variables);\n    var queryInfo = this.getQuery(queryId);\n    var oldNetworkStatus = queryInfo.networkStatus;\n    var _a = options.fetchPolicy,\n        fetchPolicy = _a === void 0 ? \"cache-first\" : _a,\n        _b = options.errorPolicy,\n        errorPolicy = _b === void 0 ? \"none\" : _b,\n        _c = options.returnPartialData,\n        returnPartialData = _c === void 0 ? false : _c,\n        _d = options.notifyOnNetworkStatusChange,\n        notifyOnNetworkStatusChange = _d === void 0 ? false : _d,\n        _e = options.context,\n        context = _e === void 0 ? {} : _e;\n    var mightUseNetwork = fetchPolicy === \"cache-first\" || fetchPolicy === \"cache-and-network\" || fetchPolicy === \"network-only\" || fetchPolicy === \"no-cache\";\n\n    if (mightUseNetwork && notifyOnNetworkStatusChange && typeof oldNetworkStatus === \"number\" && oldNetworkStatus !== networkStatus && isNetworkRequestInFlight(networkStatus)) {\n      if (fetchPolicy !== \"cache-first\") {\n        fetchPolicy = \"cache-and-network\";\n      }\n\n      returnPartialData = true;\n    }\n\n    var normalized = Object.assign({}, options, {\n      query: query,\n      variables: variables,\n      fetchPolicy: fetchPolicy,\n      errorPolicy: errorPolicy,\n      returnPartialData: returnPartialData,\n      notifyOnNetworkStatusChange: notifyOnNetworkStatusChange,\n      context: context\n    });\n\n    var fromVariables = function (variables) {\n      normalized.variables = variables;\n      return _this.fetchQueryByPolicy(queryInfo, normalized, networkStatus);\n    };\n\n    this.fetchCancelFns.set(queryId, function (reason) {\n      Promise.resolve().then(function () {\n        return concast.cancel(reason);\n      });\n    });\n    var concast = new Concast(this.transform(normalized.query).hasClientExports ? this.localState.addExportedVariables(normalized.query, normalized.variables, normalized.context).then(fromVariables) : fromVariables(normalized.variables));\n    concast.cleanup(function () {\n      _this.fetchCancelFns.delete(queryId);\n\n      var nextFetchPolicy = options.nextFetchPolicy;\n\n      if (nextFetchPolicy) {\n        options.nextFetchPolicy = void 0;\n        options.fetchPolicy = typeof nextFetchPolicy === \"function\" ? nextFetchPolicy.call(options, options.fetchPolicy || \"cache-first\") : nextFetchPolicy;\n      }\n    });\n    return concast;\n  };\n\n  QueryManager.prototype.fetchQueryByPolicy = function (queryInfo, options, networkStatus) {\n    var _this = this;\n\n    var query = options.query,\n        variables = options.variables,\n        fetchPolicy = options.fetchPolicy,\n        errorPolicy = options.errorPolicy,\n        returnPartialData = options.returnPartialData,\n        context = options.context;\n    queryInfo.init({\n      document: query,\n      variables: variables,\n      lastRequestId: this.generateRequestId(),\n      networkStatus: networkStatus\n    });\n\n    var readCache = function () {\n      return queryInfo.getDiff(variables);\n    };\n\n    var resultsFromCache = function (diff, networkStatus) {\n      if (networkStatus === void 0) {\n        networkStatus = queryInfo.networkStatus || NetworkStatus.loading;\n      }\n\n      var data = diff.result;\n\n      if (process.env.NODE_ENV !== 'production' && isNonEmptyArray(diff.missing) && !equal(data, {}) && !returnPartialData) {\n        process.env.NODE_ENV === \"production\" || invariant.warn(\"Missing cache result fields: \" + diff.missing.map(function (m) {\n          return m.path.join('.');\n        }).join(', '), diff.missing);\n      }\n\n      var fromData = function (data) {\n        return Observable.of(__assign({\n          data: data,\n          loading: isNetworkRequestInFlight(networkStatus),\n          networkStatus: networkStatus\n        }, diff.complete ? null : {\n          partial: true\n        }));\n      };\n\n      if (_this.transform(query).hasForcedResolvers) {\n        return _this.localState.runResolvers({\n          document: query,\n          remoteResult: {\n            data: data\n          },\n          context: context,\n          variables: variables,\n          onlyRunForcedResolvers: true\n        }).then(function (resolved) {\n          return fromData(resolved.data);\n        });\n      }\n\n      return fromData(data);\n    };\n\n    var resultsFromLink = function (allowCacheWrite) {\n      return _this.getResultsFromLink(queryInfo, allowCacheWrite, {\n        variables: variables,\n        context: context,\n        fetchPolicy: fetchPolicy,\n        errorPolicy: errorPolicy\n      });\n    };\n\n    switch (fetchPolicy) {\n      default:\n      case \"cache-first\":\n        {\n          var diff = readCache();\n\n          if (diff.complete) {\n            return [resultsFromCache(diff, queryInfo.markReady())];\n          }\n\n          if (returnPartialData) {\n            return [resultsFromCache(diff), resultsFromLink(true)];\n          }\n\n          return [resultsFromLink(true)];\n        }\n\n      case \"cache-and-network\":\n        {\n          var diff = readCache();\n\n          if (diff.complete || returnPartialData) {\n            return [resultsFromCache(diff), resultsFromLink(true)];\n          }\n\n          return [resultsFromLink(true)];\n        }\n\n      case \"cache-only\":\n        return [resultsFromCache(readCache(), queryInfo.markReady())];\n\n      case \"network-only\":\n        return [resultsFromLink(true)];\n\n      case \"no-cache\":\n        return [resultsFromLink(false)];\n\n      case \"standby\":\n        return [];\n    }\n  };\n\n  QueryManager.prototype.getQuery = function (queryId) {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this.cache));\n    }\n\n    return this.queries.get(queryId);\n  };\n\n  QueryManager.prototype.prepareContext = function (context) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    var newContext = this.localState.prepareContext(context);\n    return __assign(__assign({}, newContext), {\n      clientAwareness: this.clientAwareness\n    });\n  };\n\n  return QueryManager;\n}();\n\nexport { QueryManager };","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","equal","execute","getDefaultValues","getOperationDefinition","getOperationName","hasClientExports","graphQLResultHasError","removeConnectionDirectiveFromDocument","canUseWeakMap","Observable","asyncMap","isNonEmptyArray","Concast","ApolloError","isApolloError","ObservableQuery","NetworkStatus","isNetworkRequestInFlight","LocalState","QueryInfo","shouldWriteResult","Object","prototype","hasOwnProperty","_a","cache","link","_b","queryDeduplication","onBroadcast","_c","ssrMode","_d","clientAwareness","localState","assumeImmutableResults","Map","WeakMap","mutationStore","create","QueryManager","queries","forEach","_info","queryId","_this","stopQueryNoBroadcast","cancelPendingFetches","process","NODE_ENV","error","fetchCancelFns","clear","mutation","variables","optimisticResponse","updateQueries","refetchQueries","awaitRefetchQueries","updateWithProxyFn","errorPolicy","fetchPolicy","_e","context","mutationId","generateMutationId","transform","document","getVariables","addExportedVariables","_f","mutationStoreValue","loading","markMutationOptimistic","update","broadcastQueries","self","Promise","resolve","reject","storeResult","getObservableFromLink","__assign","subscribe","next","result","graphQLErrors","errors","markMutationResult","e","networkError","err","removeOptimistic","complete","refetchQueryPromises","refetchQuery","observableQuery","queryName","push","refetch","queryOptions","query","all","then","cacheWrites_1","data","dataId","updateQueries_1","call","updater","get","diff","returnPartialData","optimistic","currentQueryResult","nextQueryResult","mutationResult","queryVariables","performTransaction","write","c","recordOptimisticTransaction","options","networkStatus","fetchQueryObservable","promise","store","info","queryInfo","undefined","transformCache","has","transformed","transformDocument","forLink","transformForLink","clientQuery","serverQuery","cacheEntry_1","hasForcedResolvers","shouldForceResolvers","defaultVars","add","doc","set","notifyOnNetworkStatusChange","observable","queryManager","init","generateQueryId","fetchQuery","finally","stopQuery","String","queryIdCounter","requestIdCounter","mutationIdCounter","stopQueryInStoreNoBroadcast","stop","reset","clearStore","reFetchObservableQueries","includeStandby","observableQueryPromises","hasObservers","resetLastResults","getQuery","setDiff","setObservableQuery","makeObservable","map","observablePromise_1","sub","observer","unsubscribe","removeQuery","delete","notify","deduplication","inFlightLinkObservables_1","operation","operationName","prepareContext","forceFetch","byVariables_1","varJson_1","JSON","stringify","concast","cleanup","size","of","runResolvers","remoteResult","allowCacheWrite","hasErrors","lastRequestId","markError","markResult","markReady","aqr","ready","oldNetworkStatus","mightUseNetwork","normalized","assign","fromVariables","fetchQueryByPolicy","cancel","reason","nextFetchPolicy","generateRequestId","readCache","getDiff","resultsFromCache","env","missing","m","join","fromData","partial","onlyRunForcedResolvers","resolved","resultsFromLink","getResultsFromLink","newContext"],"sourceRoot":"","sources":["../../src/core/QueryManager.ts"],"sourcesContent":["import { DocumentNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { equal } from '@wry/equality';\n\nimport { ApolloLink, execute, FetchResult } from '../link/core';\nimport { Cache, ApolloCache } from '../cache';\n\nimport {\n  getDefaultValues,\n  getOperationDefinition,\n  getOperationName,\n  hasClientExports,\n  graphQLResultHasError,\n  removeConnectionDirectiveFromDocument,\n  canUseWeakMap,\n  ObservableSubscription,\n  Observable,\n  asyncMap,\n  isNonEmptyArray,\n  Concast,\n  ConcastSourcesIterable,\n} from '../utilities';\nimport { ApolloError, isApolloError } from '../errors';\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  SubscriptionOptions,\n  MutationOptions,\n  WatchQueryFetchPolicy,\n  ErrorPolicy,\n} from './watchQueryOptions';\nimport { ObservableQuery } from './ObservableQuery';\nimport { NetworkStatus, isNetworkRequestInFlight } from './networkStatus';\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n} from './types';\nimport { LocalState } from './LocalState';\n\nimport { QueryInfo, QueryStoreValue, shouldWriteResult } from './QueryInfo';\n\nconst { hasOwnProperty } = Object.prototype;\n\ninterface MutationStoreValue {\n  mutation: DocumentNode;\n  variables: Record<string, any>;\n  loading: boolean;\n  error: Error | null;\n}\n\nexport class QueryManager<TStore> {\n  public cache: ApolloCache<TStore>;\n  public link: ApolloLink;\n  public readonly assumeImmutableResults: boolean;\n  public readonly ssrMode: boolean;\n\n  private queryDeduplication: boolean;\n  private clientAwareness: Record<string, string> = {};\n  private localState: LocalState<TStore>;\n\n  private onBroadcast?: () => void;\n  public mutationStore?: {\n    [mutationId: string]: MutationStoreValue;\n  };\n\n  // All the queries that the QueryManager is currently managing (not\n  // including mutations and subscriptions).\n  private queries = new Map<string, QueryInfo>();\n\n  // Maps from queryId strings to Promise rejection functions for\n  // currently active queries and fetches.\n  private fetchCancelFns = new Map<string, (error: any) => any>();\n\n  constructor({\n    cache,\n    link,\n    queryDeduplication = false,\n    onBroadcast,\n    ssrMode = false,\n    clientAwareness = {},\n    localState,\n    assumeImmutableResults,\n  }: {\n    cache: ApolloCache<TStore>;\n    link: ApolloLink;\n    queryDeduplication?: boolean;\n    onBroadcast?: () => void;\n    ssrMode?: boolean;\n    clientAwareness?: Record<string, string>;\n    localState?: LocalState<TStore>;\n    assumeImmutableResults?: boolean;\n  }) {\n    this.cache = cache;\n    this.link = link;\n    this.queryDeduplication = queryDeduplication;\n    this.clientAwareness = clientAwareness;\n    this.localState = localState || new LocalState({ cache });\n    this.ssrMode = ssrMode;\n    this.assumeImmutableResults = !!assumeImmutableResults;\n    if ((this.onBroadcast = onBroadcast)) {\n      this.mutationStore = Object.create(null);\n    }\n  }\n\n  /**\n   * Call this method to terminate any active query processes, making it safe\n   * to dispose of this QueryManager instance.\n   */\n  public stop() {\n    this.queries.forEach((_info, queryId) => {\n      this.stopQueryNoBroadcast(queryId);\n    });\n\n    this.cancelPendingFetches(\n      new InvariantError('QueryManager stopped while query was in flight'),\n    );\n  }\n\n  private cancelPendingFetches(error: Error) {\n    this.fetchCancelFns.forEach(cancel => cancel(error));\n    this.fetchCancelFns.clear();\n  }\n\n  public async mutate<T>({\n    mutation,\n    variables,\n    optimisticResponse,\n    updateQueries,\n    refetchQueries = [],\n    awaitRefetchQueries = false,\n    update: updateWithProxyFn,\n    errorPolicy = 'none',\n    fetchPolicy,\n    context = {},\n  }: MutationOptions): Promise<FetchResult<T>> {\n    invariant(\n      mutation,\n      'mutation option is required. You must specify your GraphQL document in the mutation option.',\n    );\n\n    invariant(\n      !fetchPolicy || fetchPolicy === 'no-cache',\n      \"Mutations only support a 'no-cache' fetchPolicy. If you don't want to disable the cache, remove your fetchPolicy setting to proceed with the default mutation behavior.\"\n    );\n\n    const mutationId = this.generateMutationId();\n    mutation = this.transform(mutation).document;\n\n    variables = this.getVariables(mutation, variables);\n\n    if (this.transform(mutation).hasClientExports) {\n      variables = await this.localState.addExportedVariables(mutation, variables, context);\n    }\n\n    const mutationStoreValue =\n      this.mutationStore &&\n      (this.mutationStore[mutationId] = {\n        mutation,\n        variables,\n        loading: true,\n        error: null,\n      } as MutationStoreValue);\n\n    if (optimisticResponse) {\n      this.markMutationOptimistic<T>(optimisticResponse, {\n        mutationId,\n        document: mutation,\n        variables,\n        errorPolicy,\n        updateQueries,\n        update: updateWithProxyFn,\n      });\n    }\n\n    this.broadcastQueries();\n\n    const self = this;\n\n    return new Promise((resolve, reject) => {\n      let storeResult: FetchResult<T> | null;\n      let error: ApolloError;\n\n      self.getObservableFromLink(\n        mutation,\n        {\n          ...context,\n          optimisticResponse,\n        },\n        variables,\n        false,\n      ).subscribe({\n        next(result: FetchResult<T>) {\n          if (graphQLResultHasError(result) && errorPolicy === 'none') {\n            error = new ApolloError({\n              graphQLErrors: result.errors,\n            });\n            return;\n          }\n\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = null;\n          }\n\n          if (fetchPolicy !== 'no-cache') {\n            try {\n              self.markMutationResult<T>({\n                mutationId,\n                result,\n                document: mutation,\n                variables,\n                errorPolicy,\n                updateQueries,\n                update: updateWithProxyFn,\n              });\n            } catch (e) {\n              error = new ApolloError({\n                networkError: e,\n              });\n              return;\n            }\n          }\n\n          storeResult = result;\n        },\n\n        error(err: Error) {\n          if (mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = err;\n          }\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n          self.broadcastQueries();\n          reject(\n            new ApolloError({\n              networkError: err,\n            }),\n          );\n        },\n\n        complete() {\n          if (error && mutationStoreValue) {\n            mutationStoreValue.loading = false;\n            mutationStoreValue.error = error;\n          }\n\n          if (optimisticResponse) {\n            self.cache.removeOptimistic(mutationId);\n          }\n\n          self.broadcastQueries();\n\n          if (error) {\n            reject(error);\n            return;\n          }\n\n          // allow for conditional refetches\n          // XXX do we want to make this the only API one day?\n          if (typeof refetchQueries === 'function') {\n            refetchQueries = refetchQueries(storeResult!);\n          }\n\n          const refetchQueryPromises: Promise<\n            ApolloQueryResult<any>[] | ApolloQueryResult<{}>\n          >[] = [];\n\n          if (isNonEmptyArray(refetchQueries)) {\n            refetchQueries.forEach(refetchQuery => {\n              if (typeof refetchQuery === 'string') {\n                self.queries.forEach(({ observableQuery }) => {\n                  if (observableQuery &&\n                      observableQuery.queryName === refetchQuery) {\n                    refetchQueryPromises.push(observableQuery.refetch());\n                  }\n                });\n              } else {\n                const queryOptions: QueryOptions = {\n                  query: refetchQuery.query,\n                  variables: refetchQuery.variables,\n                  fetchPolicy: 'network-only',\n                };\n\n                if (refetchQuery.context) {\n                  queryOptions.context = refetchQuery.context;\n                }\n\n                refetchQueryPromises.push(self.query(queryOptions));\n              }\n            });\n          }\n\n          Promise.all(\n            awaitRefetchQueries ? refetchQueryPromises : [],\n          ).then(() => {\n            if (\n              errorPolicy === 'ignore' &&\n              storeResult &&\n              graphQLResultHasError(storeResult)\n            ) {\n              delete storeResult.errors;\n            }\n\n            resolve(storeResult!);\n          }, reject);\n        },\n      });\n    });\n  }\n\n  public markMutationResult<TData>(\n    mutation: {\n      mutationId: string;\n      result: FetchResult<TData>;\n      document: DocumentNode;\n      variables?: OperationVariables;\n      errorPolicy: ErrorPolicy;\n      updateQueries: MutationOptions<TData>[\"updateQueries\"],\n      update?: (\n        cache: ApolloCache<TStore>,\n        result: FetchResult<TData>,\n      ) => void;\n    },\n    cache = this.cache,\n  ) {\n    if (shouldWriteResult(mutation.result, mutation.errorPolicy)) {\n      const cacheWrites: Cache.WriteOptions[] = [{\n        result: mutation.result.data,\n        dataId: 'ROOT_MUTATION',\n        query: mutation.document,\n        variables: mutation.variables,\n      }];\n\n      const { updateQueries } = mutation;\n      if (updateQueries) {\n        this.queries.forEach(({ observableQuery }, queryId) => {\n          const queryName = observableQuery && observableQuery.queryName;\n          if (!queryName || !hasOwnProperty.call(updateQueries, queryName)) {\n            return;\n          }\n          const updater = updateQueries[queryName];\n          const { document, variables } = this.queries.get(queryId)!;\n\n          // Read the current query result from the store.\n          const { result: currentQueryResult, complete } = cache.diff<TData>({\n            query: document!,\n            variables,\n            returnPartialData: true,\n            optimistic: false,\n          });\n\n          if (complete && currentQueryResult) {\n            // Run our reducer using the current query result and the mutation result.\n            const nextQueryResult = updater(currentQueryResult, {\n              mutationResult: mutation.result,\n              queryName: document && getOperationName(document) || void 0,\n              queryVariables: variables!,\n            });\n\n            // Write the modified result back into the store if we got a new result.\n            if (nextQueryResult) {\n              cacheWrites.push({\n                result: nextQueryResult,\n                dataId: 'ROOT_QUERY',\n                query: document!,\n                variables,\n              });\n            }\n          }\n        });\n      }\n\n      cache.performTransaction(c => {\n        cacheWrites.forEach(write => c.write(write));\n\n        // If the mutation has some writes associated with it then we need to\n        // apply those writes to the store by running this reducer again with a\n        // write action.\n        const { update } = mutation;\n        if (update) {\n          update(c, mutation.result);\n        }\n      }, /* non-optimistic transaction: */ null);\n    }\n  }\n\n  public markMutationOptimistic<TData>(\n    optimisticResponse: any,\n    mutation: {\n      mutationId: string;\n      document: DocumentNode;\n      variables?: OperationVariables;\n      errorPolicy: ErrorPolicy;\n      updateQueries: MutationOptions<TData>[\"updateQueries\"],\n      update?: (\n        cache: ApolloCache<TStore>,\n        result: FetchResult<TData>,\n      ) => void;\n    },\n  ) {\n    const data = typeof optimisticResponse === \"function\"\n      ? optimisticResponse(mutation.variables)\n      : optimisticResponse;\n\n    return this.cache.recordOptimisticTransaction(cache => {\n      try {\n        this.markMutationResult<TData>({\n          ...mutation,\n          result: { data },\n        }, cache);\n      } catch (error) {\n        invariant.error(error);\n      }\n    }, mutation.mutationId);\n  }\n\n  public fetchQuery<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    networkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    return this.fetchQueryObservable<TData, TVars>(\n      queryId,\n      options,\n      networkStatus,\n    ).promise;\n  }\n\n  public getQueryStore() {\n    const store: Record<string, QueryStoreValue> = Object.create(null);\n    this.queries.forEach((info, queryId) => {\n      store[queryId] = {\n        variables: info.variables,\n        networkStatus: info.networkStatus,\n        networkError: info.networkError,\n        graphQLErrors: info.graphQLErrors,\n      };\n    });\n    return store;\n  }\n\n  public resetErrors(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) {\n      queryInfo.networkError = undefined;\n      queryInfo.graphQLErrors = [];\n    }\n  }\n\n  private transformCache = new (canUseWeakMap ? WeakMap : Map)<\n    DocumentNode,\n    Readonly<{\n      document: Readonly<DocumentNode>;\n      hasClientExports: boolean;\n      hasForcedResolvers: boolean;\n      clientQuery: Readonly<DocumentNode> | null;\n      serverQuery: Readonly<DocumentNode> | null;\n      defaultVars: Readonly<OperationVariables>;\n    }>\n  >();\n\n  public transform(document: DocumentNode) {\n    const { transformCache } = this;\n\n    if (!transformCache.has(document)) {\n      const transformed = this.cache.transformDocument(document);\n      const forLink = removeConnectionDirectiveFromDocument(\n        this.cache.transformForLink(transformed));\n\n      const clientQuery = this.localState.clientQuery(transformed);\n      const serverQuery = forLink && this.localState.serverQuery(forLink);\n\n      const cacheEntry = {\n        document: transformed,\n        // TODO These two calls (hasClientExports and shouldForceResolvers)\n        // could probably be merged into a single traversal.\n        hasClientExports: hasClientExports(transformed),\n        hasForcedResolvers: this.localState.shouldForceResolvers(transformed),\n        clientQuery,\n        serverQuery,\n        defaultVars: getDefaultValues(\n          getOperationDefinition(transformed)\n        ) as OperationVariables,\n      };\n\n      const add = (doc: DocumentNode | null) => {\n        if (doc && !transformCache.has(doc)) {\n          transformCache.set(doc, cacheEntry);\n        }\n      }\n      // Add cacheEntry to the transformCache using several different keys,\n      // since any one of these documents could end up getting passed to the\n      // transform method again in the future.\n      add(document);\n      add(transformed);\n      add(clientQuery);\n      add(serverQuery);\n    }\n\n    return transformCache.get(document)!;\n  }\n\n  private getVariables(\n    document: DocumentNode,\n    variables?: OperationVariables,\n  ): OperationVariables {\n    return {\n      ...this.transform(document).defaultVars,\n      ...variables,\n    };\n  }\n\n  public watchQuery<T, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    // assign variable default values if supplied\n    options = {\n      ...options,\n      variables: this.getVariables(\n        options.query,\n        options.variables,\n      ) as TVariables,\n    };\n\n    if (typeof options.notifyOnNetworkStatusChange === 'undefined') {\n      options.notifyOnNetworkStatusChange = false;\n    }\n\n    const queryInfo = new QueryInfo(this.cache);\n    const observable = new ObservableQuery<T, TVariables>({\n      queryManager: this,\n      queryInfo,\n      options,\n    });\n\n    this.queries.set(observable.queryId, queryInfo);\n\n    queryInfo.init({\n      document: options.query,\n      observableQuery: observable,\n      variables: options.variables,\n    });\n\n    return observable;\n  }\n\n  public query<TData, TVars = OperationVariables>(\n    options: QueryOptions<TVars, TData>,\n  ): Promise<ApolloQueryResult<TData>> {\n    invariant(\n      options.query,\n      'query option is required. You must specify your GraphQL document ' +\n        'in the query option.',\n    );\n\n    invariant(\n      options.query.kind === 'Document',\n      'You must wrap the query string in a \"gql\" tag.',\n    );\n\n    invariant(\n      !(options as any).returnPartialData,\n      'returnPartialData option only supported on watchQuery.',\n    );\n\n    invariant(\n      !(options as any).pollInterval,\n      'pollInterval option only supported on watchQuery.',\n    );\n\n    const queryId = this.generateQueryId();\n    return this.fetchQuery<TData, TVars>(\n      queryId,\n      options,\n    ).finally(() => this.stopQuery(queryId));\n  }\n\n  private queryIdCounter = 1;\n  public generateQueryId() {\n    return String(this.queryIdCounter++);\n  }\n\n  private requestIdCounter = 1;\n  public generateRequestId() {\n    return this.requestIdCounter++;\n  }\n\n  private mutationIdCounter = 1;\n  public generateMutationId() {\n    return String(this.mutationIdCounter++);\n  }\n\n  public stopQueryInStore(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryInStoreNoBroadcast(queryId: string) {\n    const queryInfo = this.queries.get(queryId);\n    if (queryInfo) queryInfo.stop();\n  }\n\n  public clearStore(): Promise<void> {\n    // Before we have sent the reset action to the store, we can no longer\n    // rely on the results returned by in-flight requests since these may\n    // depend on values that previously existed in the data portion of the\n    // store. So, we cancel the promises and observers that we have issued\n    // so far and not yet resolved (in the case of queries).\n    this.cancelPendingFetches(new InvariantError(\n      'Store reset while query was in flight (not completed in link chain)',\n    ));\n\n    this.queries.forEach(queryInfo => {\n      if (queryInfo.observableQuery) {\n        // Set loading to true so listeners don't trigger unless they want\n        // results with partial data.\n        queryInfo.networkStatus = NetworkStatus.loading;\n      } else {\n        queryInfo.stop();\n      }\n    });\n\n    if (this.mutationStore) {\n      this.mutationStore = Object.create(null);\n    }\n\n    // begin removing data from the store\n    return this.cache.reset();\n  }\n\n  public resetStore(): Promise<ApolloQueryResult<any>[]> {\n    // Similarly, we have to have to refetch each of the queries currently being\n    // observed. We refetch instead of error'ing on these since the assumption is that\n    // resetting the store doesn't eliminate the need for the queries currently being\n    // watched. If there is an existing query in flight when the store is reset,\n    // the promise for it will be rejected and its results will not be written to the\n    // store.\n    return this.clearStore().then(() => {\n      return this.reFetchObservableQueries();\n    });\n  }\n\n  public reFetchObservableQueries(\n    includeStandby: boolean = false,\n  ): Promise<ApolloQueryResult<any>[]> {\n    const observableQueryPromises: Promise<ApolloQueryResult<any>>[] = [];\n\n    this.queries.forEach(({ observableQuery }, queryId) => {\n      if (observableQuery && observableQuery.hasObservers()) {\n        const fetchPolicy = observableQuery.options.fetchPolicy;\n\n        observableQuery.resetLastResults();\n        if (\n          fetchPolicy !== 'cache-only' &&\n          (includeStandby || fetchPolicy !== 'standby')\n        ) {\n          observableQueryPromises.push(observableQuery.refetch());\n        }\n\n        this.getQuery(queryId).setDiff(null);\n      }\n    });\n\n    this.broadcastQueries();\n\n    return Promise.all(observableQueryPromises);\n  }\n\n  public setObservableQuery(observableQuery: ObservableQuery<any, any>) {\n    this.getQuery(observableQuery.queryId).setObservableQuery(observableQuery);\n  }\n\n  public startGraphQLSubscription<T = any>({\n    query,\n    fetchPolicy,\n    errorPolicy,\n    variables,\n    context = {},\n  }: SubscriptionOptions): Observable<FetchResult<T>> {\n    query = this.transform(query).document;\n    variables = this.getVariables(query, variables);\n\n    const makeObservable = (variables: OperationVariables) =>\n      this.getObservableFromLink<T>(\n        query,\n        context,\n        variables,\n        false,\n      ).map(result => {\n        if (fetchPolicy !== 'no-cache') {\n          // the subscription interface should handle not sending us results we no longer subscribe to.\n          // XXX I don't think we ever send in an object with errors, but we might in the future...\n          if (shouldWriteResult(result, errorPolicy)) {\n            this.cache.write({\n              query,\n              result: result.data,\n              dataId: 'ROOT_SUBSCRIPTION',\n              variables: variables,\n            });\n          }\n\n          this.broadcastQueries();\n        }\n\n        if (graphQLResultHasError(result)) {\n          throw new ApolloError({\n            graphQLErrors: result.errors,\n          });\n        }\n\n        return result;\n      });\n\n    if (this.transform(query).hasClientExports) {\n      const observablePromise = this.localState.addExportedVariables(\n        query,\n        variables,\n        context,\n      ).then(makeObservable);\n\n      return new Observable<FetchResult<T>>(observer => {\n        let sub: ObservableSubscription | null = null;\n        observablePromise.then(\n          observable => sub = observable.subscribe(observer),\n          observer.error,\n        );\n        return () => sub && sub.unsubscribe();\n      });\n    }\n\n    return makeObservable(variables);\n  }\n\n  public stopQuery(queryId: string) {\n    this.stopQueryNoBroadcast(queryId);\n    this.broadcastQueries();\n  }\n\n  private stopQueryNoBroadcast(queryId: string) {\n    this.stopQueryInStoreNoBroadcast(queryId);\n    this.removeQuery(queryId);\n  }\n\n  public removeQuery(queryId: string) {\n    // teardown all links\n    // Both `QueryManager.fetchRequest` and `QueryManager.query` create separate promises\n    // that each add their reject functions to fetchCancelFns.\n    // A query created with `QueryManager.query()` could trigger a `QueryManager.fetchRequest`.\n    // The same queryId could have two rejection fns for two promises\n    this.fetchCancelFns.delete(queryId);\n    this.getQuery(queryId).stop();\n    this.queries.delete(queryId);\n  }\n\n  public broadcastQueries() {\n    if (this.onBroadcast) this.onBroadcast();\n    this.queries.forEach(info => info.notify());\n  }\n\n  public getLocalState(): LocalState<TStore> {\n    return this.localState;\n  }\n\n  private inFlightLinkObservables = new Map<\n    DocumentNode,\n    Map<string, Observable<FetchResult>>\n  >();\n\n  private getObservableFromLink<T = any>(\n    query: DocumentNode,\n    context: any,\n    variables?: OperationVariables,\n    deduplication: boolean =\n      // Prefer context.queryDeduplication if specified.\n      context?.queryDeduplication ??\n      this.queryDeduplication,\n  ): Observable<FetchResult<T>> {\n    let observable: Observable<FetchResult<T>>;\n\n    const { serverQuery } = this.transform(query);\n    if (serverQuery) {\n      const { inFlightLinkObservables, link } = this;\n\n      const operation = {\n        query: serverQuery,\n        variables,\n        operationName: getOperationName(serverQuery) || void 0,\n        context: this.prepareContext({\n          ...context,\n          forceFetch: !deduplication\n        }),\n      };\n\n      context = operation.context;\n\n      if (deduplication) {\n        const byVariables = inFlightLinkObservables.get(serverQuery) || new Map();\n        inFlightLinkObservables.set(serverQuery, byVariables);\n\n        const varJson = JSON.stringify(variables);\n        observable = byVariables.get(varJson);\n\n        if (!observable) {\n          const concast = new Concast([\n            execute(link, operation) as Observable<FetchResult<T>>\n          ]);\n\n          byVariables.set(varJson, observable = concast);\n\n          concast.cleanup(() => {\n            if (byVariables.delete(varJson) &&\n                byVariables.size < 1) {\n              inFlightLinkObservables.delete(serverQuery);\n            }\n          });\n        }\n\n      } else {\n        observable = new Concast([\n          execute(link, operation) as Observable<FetchResult<T>>\n        ]);\n      }\n    } else {\n      observable = new Concast([\n        Observable.of({ data: {} } as FetchResult<T>)\n      ]);\n      context = this.prepareContext(context);\n    }\n\n    const { clientQuery } = this.transform(query);\n    if (clientQuery) {\n      observable = asyncMap(observable, result => {\n        return this.localState.runResolvers({\n          document: clientQuery,\n          remoteResult: result,\n          context,\n          variables,\n        });\n      });\n    }\n\n    return observable;\n  }\n\n  private getResultsFromLink<TData, TVars>(\n    queryInfo: QueryInfo,\n    allowCacheWrite: boolean,\n    options: Pick<WatchQueryOptions<TVars, TData>,\n      | \"variables\"\n      | \"context\"\n      | \"fetchPolicy\"\n      | \"errorPolicy\">,\n  ): Observable<ApolloQueryResult<TData>> {\n    const { lastRequestId } = queryInfo;\n\n    return asyncMap(\n      this.getObservableFromLink(\n        queryInfo.document!,\n        options.context,\n        options.variables,\n      ),\n\n      result => {\n        const hasErrors = isNonEmptyArray(result.errors);\n\n        if (lastRequestId >= queryInfo.lastRequestId) {\n          if (hasErrors && options.errorPolicy === \"none\") {\n            // Throwing here effectively calls observer.error.\n            throw queryInfo.markError(new ApolloError({\n              graphQLErrors: result.errors,\n            }));\n          }\n          queryInfo.markResult(result, options, allowCacheWrite);\n          queryInfo.markReady();\n        }\n\n        const aqr: ApolloQueryResult<TData> = {\n          data: result.data,\n          loading: false,\n          networkStatus: queryInfo.networkStatus || NetworkStatus.ready,\n        };\n\n        if (hasErrors && options.errorPolicy !== \"ignore\") {\n          aqr.errors = result.errors;\n        }\n\n        return aqr;\n      },\n\n      networkError => {\n        const error = isApolloError(networkError)\n          ? networkError\n          : new ApolloError({ networkError });\n\n        if (lastRequestId >= queryInfo.lastRequestId) {\n          queryInfo.markError(error);\n        }\n\n        throw error;\n      },\n    );\n  }\n\n  public fetchQueryObservable<TData, TVars>(\n    queryId: string,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus = NetworkStatus.loading,\n  ): Concast<ApolloQueryResult<TData>> {\n    const query = this.transform(options.query).document;\n    const variables = this.getVariables(query, options.variables) as TVars;\n    const queryInfo = this.getQuery(queryId);\n    const oldNetworkStatus = queryInfo.networkStatus;\n\n    let {\n      fetchPolicy = \"cache-first\" as WatchQueryFetchPolicy,\n      errorPolicy = \"none\" as ErrorPolicy,\n      returnPartialData = false,\n      notifyOnNetworkStatusChange = false,\n      context = {},\n    } = options;\n\n    const mightUseNetwork =\n      fetchPolicy === \"cache-first\" ||\n      fetchPolicy === \"cache-and-network\" ||\n      fetchPolicy === \"network-only\" ||\n      fetchPolicy === \"no-cache\";\n\n    if (mightUseNetwork &&\n        notifyOnNetworkStatusChange &&\n        typeof oldNetworkStatus === \"number\" &&\n        oldNetworkStatus !== networkStatus &&\n        isNetworkRequestInFlight(networkStatus)) {\n      // In order to force delivery of an incomplete cache result with\n      // loading:true, we tweak the fetchPolicy to include the cache, and\n      // pretend that returnPartialData was enabled.\n      if (fetchPolicy !== \"cache-first\") {\n        fetchPolicy = \"cache-and-network\";\n      }\n      returnPartialData = true;\n    }\n\n    const normalized = Object.assign({}, options, {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      notifyOnNetworkStatusChange,\n      context,\n    });\n\n    const fromVariables = (variables: TVars) => {\n      // Since normalized is always a fresh copy of options, it's safe to\n      // modify its properties here, rather than creating yet another new\n      // WatchQueryOptions object.\n      normalized.variables = variables;\n      return this.fetchQueryByPolicy<TData, TVars>(\n        queryInfo,\n        normalized,\n        networkStatus,\n      );\n    };\n\n    // This cancel function needs to be set before the concast is created,\n    // in case concast creation synchronously cancels the request.\n    this.fetchCancelFns.set(queryId, reason => {\n      // Delaying the cancellation using a Promise ensures that the\n      // concast variable has been initialized.\n      Promise.resolve().then(() => concast.cancel(reason));\n    });\n\n    // A Concast<T> can be created either from an Iterable<Observable<T>>\n    // or from a PromiseLike<Iterable<Observable<T>>>, where T in this\n    // case is ApolloQueryResult<TData>.\n    const concast = new Concast(\n      // If the query has @export(as: ...) directives, then we need to\n      // process those directives asynchronously. When there are no\n      // @export directives (the common case), we deliberately avoid\n      // wrapping the result of this.fetchQueryByPolicy in a Promise,\n      // since the timing of result delivery is (unfortunately) important\n      // for backwards compatibility. TODO This code could be simpler if\n      // we deprecated and removed LocalState.\n      this.transform(normalized.query).hasClientExports\n        ? this.localState.addExportedVariables(\n          normalized.query,\n          normalized.variables,\n          normalized.context,\n        ).then(fromVariables)\n        : fromVariables(normalized.variables!)\n    );\n\n    concast.cleanup(() => {\n      this.fetchCancelFns.delete(queryId);\n\n      const { nextFetchPolicy } = options;\n      if (nextFetchPolicy) {\n        // The options.nextFetchPolicy transition should happen only once,\n        // but it should be possible for a nextFetchPolicy function to set\n        // this.nextFetchPolicy to perform an additional transition.\n        options.nextFetchPolicy = void 0;\n\n        // When someone chooses cache-and-network or network-only as their\n        // initial FetchPolicy, they often do not want future cache updates to\n        // trigger unconditional network requests, which is what repeatedly\n        // applying the cache-and-network or network-only policies would seem\n        // to imply. Instead, when the cache reports an update after the\n        // initial network request, it may be desirable for subsequent network\n        // requests to be triggered only if the cache result is incomplete.\n        // The options.nextFetchPolicy option provides an easy way to update\n        // options.fetchPolicy after the intial network request, without\n        // having to call observableQuery.setOptions.\n        options.fetchPolicy = typeof nextFetchPolicy === \"function\"\n          ? nextFetchPolicy.call(options, options.fetchPolicy || \"cache-first\")\n          : nextFetchPolicy;\n      }\n    });\n\n    return concast;\n  }\n\n  private fetchQueryByPolicy<TData, TVars>(\n    queryInfo: QueryInfo,\n    options: WatchQueryOptions<TVars, TData>,\n    // The initial networkStatus for this fetch, most often\n    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,\n    // or setVariables.\n    networkStatus: NetworkStatus,\n  ): ConcastSourcesIterable<ApolloQueryResult<TData>> {\n    const {\n      query,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      returnPartialData,\n      context,\n    } = options;\n\n    queryInfo.init({\n      document: query,\n      variables,\n      lastRequestId: this.generateRequestId(),\n      networkStatus,\n    });\n\n    const readCache = () => queryInfo.getDiff(variables);\n\n    const resultsFromCache = (\n      diff: Cache.DiffResult<TData>,\n      networkStatus = queryInfo.networkStatus || NetworkStatus.loading,\n    ) => {\n      const data = diff.result as TData;\n\n      if (process.env.NODE_ENV !== 'production' &&\n          isNonEmptyArray(diff.missing) &&\n          !equal(data, {}) &&\n          !returnPartialData) {\n        invariant.warn(`Missing cache result fields: ${\n          diff.missing.map(m => m.path.join('.')).join(', ')\n        }`, diff.missing);\n      }\n\n      const fromData = (data: TData) => Observable.of({\n        data,\n        loading: isNetworkRequestInFlight(networkStatus),\n        networkStatus,\n        ...(diff.complete ? null : { partial: true }),\n      } as ApolloQueryResult<TData>);\n\n      if (this.transform(query).hasForcedResolvers) {\n        return this.localState.runResolvers({\n          document: query,\n          remoteResult: { data },\n          context,\n          variables,\n          onlyRunForcedResolvers: true,\n        }).then(resolved => fromData(resolved.data!));\n      }\n\n      return fromData(data);\n    };\n\n    const resultsFromLink = (allowCacheWrite: boolean) =>\n      this.getResultsFromLink<TData, TVars>(queryInfo, allowCacheWrite, {\n        variables,\n        context,\n        fetchPolicy,\n        errorPolicy,\n      });\n\n    switch (fetchPolicy) {\n    default: case \"cache-first\": {\n      const diff = readCache();\n\n      if (diff.complete) {\n        return [\n          resultsFromCache(diff, queryInfo.markReady()),\n        ];\n      }\n\n      if (returnPartialData) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(true),\n        ];\n      }\n\n      return [\n        resultsFromLink(true),\n      ];\n    }\n\n    case \"cache-and-network\": {\n      const diff = readCache();\n\n      if (diff.complete || returnPartialData) {\n        return [\n          resultsFromCache(diff),\n          resultsFromLink(true),\n        ];\n      }\n\n      return [\n        resultsFromLink(true),\n      ];\n    }\n\n    case \"cache-only\":\n      return [\n        resultsFromCache(readCache(), queryInfo.markReady()),\n      ];\n\n    case \"network-only\":\n      return [resultsFromLink(true)];\n\n    case \"no-cache\":\n      return [resultsFromLink(false)];\n\n    case \"standby\":\n      return [];\n    }\n  }\n\n  private getQuery(queryId: string): QueryInfo {\n    if (queryId && !this.queries.has(queryId)) {\n      this.queries.set(queryId, new QueryInfo(this.cache));\n    }\n    return this.queries.get(queryId)!;\n  }\n\n  private prepareContext(context = {}) {\n    const newContext = this.localState.prepareContext(context);\n    return {\n      ...newContext,\n      clientAwareness: this.clientAwareness,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}