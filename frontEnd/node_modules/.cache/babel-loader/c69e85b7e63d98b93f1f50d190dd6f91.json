{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n\n      return true;\n    });\n  }\n\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return value !== null && typeof value === \"object\" && !isReference(value) && !Array.isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}","map":{"version":3,"mappings":"AAGA,SAEEA,WAFF,EAKEC,OALF,EAMEC,UANF,EAOEC,sBAPF,EAQEC,aARF,QASO,0BATP;AAWA,OAAO,IAAMC,MAAM,GAAGC,MAAM,CAACC,SAAP,CAAiBC,cAAhC;AAEP,OAAM,SAAUC,0BAAV,CACJC,KADI,EAEJC,iBAFI,EAEsC;EAE1C,OAAOX,WAAW,CAACW,iBAAD,CAAX,GACHD,KAAK,CAACE,GAAN,CAAUD,iBAAiB,CAACE,KAA5B,EAAmC,YAAnC,CADG,GAEHF,iBAAiB,IAAIA,iBAAiB,CAACG,UAF3C;AAGD;AAED,OAAO,IAAMC,qBAAqB,GAAG,oBAA9B;AAEP,OAAM,SAAUC,sBAAV,CAAiCC,cAAjC,EAAuD;EAC3D,IAAMC,KAAK,GAAGD,cAAc,CAACC,KAAf,CAAqBH,qBAArB,CAAd;EACA,OAAOG,KAAK,GAAGA,KAAK,CAAC,CAAD,CAAR,GAAcD,cAA1B;AACD;AAED,OAAM,SAAUE,yBAAV,CACJC,YADI,EAEJC,MAFI,EAGJC,SAHI,EAG2B;EAE/B,IAAID,MAAM,IAAI,OAAOA,MAAP,KAAkB,QAAhC,EAA0C;IACxC,OAAOE,KAAK,CAACC,OAAN,CAAcH,MAAd,IACHA,MAAM,CAACI,KAAP,CAAa,gBAAI;MAAI,gCAAyB,CAACL,YAAD,EAAeM,IAAf,EAAqBJ,SAArB,CAAzB;IAAwD,CAA7E,CADG,GAEHF,YAAY,CAACO,UAAb,CAAwBF,KAAxB,CAA8B,iBAAK;MACnC,IAAIxB,OAAO,CAAC2B,KAAD,CAAP,IAAkBxB,aAAa,CAACwB,KAAD,EAAQN,SAAR,CAAnC,EAAuD;QACrD,IAAMO,GAAG,GAAG1B,sBAAsB,CAACyB,KAAD,CAAlC;QACA,OAAOvB,MAAM,CAACyB,IAAP,CAAYT,MAAZ,EAAoBQ,GAApB,MACJ,CAACD,KAAK,CAACR,YAAP,IACAD,yBAAyB,CAACS,KAAK,CAACR,YAAP,EAAqBC,MAAM,CAACQ,GAAD,CAA3B,EAAkCP,SAAlC,CAFrB,CAAP;MAGD;;MAMD,OAAO,IAAP;IACD,CAbC,CAFJ;EAgBD;;EACD,OAAO,KAAP;AACD;AAED,OAAM,SAAUS,uBAAV,CACJC,KADI,EACa;EAEjB,OAAOA,KAAK,KAAK,IAAV,IACL,OAAOA,KAAP,KAAiB,QADZ,IAEL,CAAChC,WAAW,CAACgC,KAAD,CAFP,IAGL,CAACT,KAAK,CAACC,OAAN,CAAcQ,KAAd,CAHH;AAID;AAED,OAAM,SAAUC,yBAAV,GAAmC;EACvC,OAAO,IAAI/B,UAAJ,EAAP;AACD","names":["isReference","isField","DeepMerger","resultKeyNameFromField","shouldInclude","hasOwn","Object","prototype","hasOwnProperty","getTypenameFromStoreObject","store","objectOrReference","get","__ref","__typename","TypeOrFieldNameRegExp","fieldNameFromStoreName","storeFieldName","match","selectionSetMatchesResult","selectionSet","result","variables","Array","isArray","every","item","selections","field","key","call","storeValueIsStoreObject","value","makeProcessedFieldsMerger"],"sourceRoot":"","sources":["../../../src/cache/inmemory/helpers.ts"],"sourcesContent":["import { SelectionSetNode } from 'graphql';\n\nimport { NormalizedCache } from './types';\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../../utilities';\n\nexport const hasOwn = Object.prototype.hasOwnProperty;\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (result && typeof result === \"object\") {\n    return Array.isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return value !== null &&\n    typeof value === \"object\" &&\n    !isReference(value) &&\n    !Array.isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n"]},"metadata":{},"sourceType":"module"}