{"ast":null,"code":"import stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\nimport { getFragmentFromSelection } from \"./fragments.js\";\nexport function makeReference(id) {\n  return {\n    __ref: String(id)\n  };\n}\nexport function isReference(obj) {\n  return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\n\nfunction isStringValue(value) {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value) {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value) {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value) {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value) {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value) {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value) {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value) {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value) {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(argObj, name, value, variables) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    var nestedArgObj_1 = {};\n    value.fields.map(function (obj) {\n      return valueToObjectRepresentation(nestedArgObj_1, obj.name, obj.value, variables);\n    });\n    argObj[name.value] = nestedArgObj_1;\n  } else if (isVariable(value)) {\n    var variableValue = (variables || {})[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(function (listValue) {\n      var nestedArgArrayObj = {};\n      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);\n      return nestedArgArrayObj[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw process.env.NODE_ENV === \"production\" ? new InvariantError(53) : new InvariantError(\"The inline argument \\\"\" + name.value + \"\\\" of kind \\\"\" + value.kind + \"\\\"\" + 'is not supported. Use variables instead of inline arguments to ' + 'overcome this limitation.');\n  }\n}\nexport function storeKeyNameFromField(field, variables) {\n  var directivesObj = null;\n\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(function (directive) {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(function (_a) {\n          var name = _a.name,\n              value = _a.value;\n          return valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables);\n        });\n      }\n    });\n  }\n\n  var argObj = null;\n\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj, name, value, variables);\n    });\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\nvar KNOWN_DIRECTIVES = ['connection', 'include', 'skip', 'client', 'rest', 'export'];\nexport function getStoreKeyName(fieldName, args, directives) {\n  if (args && directives && directives['connection'] && directives['connection']['key']) {\n    if (directives['connection']['filter'] && directives['connection']['filter'].length > 0) {\n      var filterKeys = directives['connection']['filter'] ? directives['connection']['filter'] : [];\n      filterKeys.sort();\n      var filteredArgs_1 = {};\n      filterKeys.forEach(function (key) {\n        filteredArgs_1[key] = args[key];\n      });\n      return directives['connection']['key'] + \"(\" + JSON.stringify(filteredArgs_1) + \")\";\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  var completeFieldName = fieldName;\n\n  if (args) {\n    var stringifiedArgs = stringify(args);\n    completeFieldName += \"(\" + stringifiedArgs + \")\";\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(function (key) {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += \"@\" + key + \"(\" + JSON.stringify(directives[key]) + \")\";\n      } else {\n        completeFieldName += \"@\" + key;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\nexport function argumentsObjectFromField(field, variables) {\n  if (field.arguments && field.arguments.length) {\n    var argObj_1 = {};\n    field.arguments.forEach(function (_a) {\n      var name = _a.name,\n          value = _a.value;\n      return valueToObjectRepresentation(argObj_1, name, value, variables);\n    });\n    return argObj_1;\n  }\n\n  return null;\n}\nexport function resultKeyNameFromField(field) {\n  return field.alias ? field.alias.value : field.name.value;\n}\nexport function getTypenameFromResult(result, selectionSet, fragmentMap) {\n  if (typeof result.__typename === 'string') {\n    return result.__typename;\n  }\n\n  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n    var selection = _a[_i];\n\n    if (isField(selection)) {\n      if (selection.name.value === '__typename') {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else {\n      var typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);\n\n      if (typeof typename === 'string') {\n        return typename;\n      }\n    }\n  }\n}\nexport function isField(selection) {\n  return selection.kind === 'Field';\n}\nexport function isInlineFragment(selection) {\n  return selection.kind === 'InlineFragment';\n}","map":{"version":3,"mappings":"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","names":["stringify","InvariantError","getFragmentFromSelection","makeReference","id","__ref","String","isReference","obj","Boolean","isStringValue","value","kind","isBooleanValue","isIntValue","isFloatValue","isVariable","isObjectValue","isListValue","isEnumValue","isNullValue","valueToObjectRepresentation","argObj","name","variables","Number","nestedArgObj_1","fields","map","variableValue","values","nestedArgArrayObj","listValue","process","NODE_ENV","storeKeyNameFromField","field","directivesObj","directives","forEach","directive","arguments","_a","length","getStoreKeyName","KNOWN_DIRECTIVES","fieldName","args","filterKeys","sort","filteredArgs_1","key","JSON","completeFieldName","stringifiedArgs","Object","keys","indexOf","argumentsObjectFromField","argObj_1","resultKeyNameFromField","alias","getTypenameFromResult","result","selectionSet","fragmentMap","__typename","selections","_i","selection","isField","typename","isInlineFragment"],"sourceRoot":"","sources":["../../../src/utilities/graphql/storeUtils.ts"],"sourcesContent":["import {\n  DirectiveNode,\n  FieldNode,\n  IntValueNode,\n  FloatValueNode,\n  StringValueNode,\n  BooleanValueNode,\n  ObjectValueNode,\n  ListValueNode,\n  EnumValueNode,\n  NullValueNode,\n  VariableNode,\n  InlineFragmentNode,\n  ValueNode,\n  SelectionNode,\n  NameNode,\n  SelectionSetNode,\n} from 'graphql';\n\nimport stringify from 'fast-json-stable-stringify';\nimport { InvariantError } from 'ts-invariant';\nimport { FragmentMap, getFragmentFromSelection } from './fragments';\n\nexport interface Reference {\n  readonly __ref: string;\n}\n\nexport function makeReference(id: string): Reference {\n  return { __ref: String(id) };\n}\n\nexport function isReference(obj: any): obj is Reference {\n  return Boolean(obj && typeof obj === 'object' && typeof obj.__ref === 'string');\n}\n\nexport type StoreValue =\n  | number\n  | string\n  | string[]\n  | Reference\n  | Reference[]\n  | null\n  | undefined\n  | void\n  | Object;\n\nexport interface StoreObject {\n  __typename?: string;\n  [storeFieldName: string]: StoreValue;\n}\n\nfunction isStringValue(value: ValueNode): value is StringValueNode {\n  return value.kind === 'StringValue';\n}\n\nfunction isBooleanValue(value: ValueNode): value is BooleanValueNode {\n  return value.kind === 'BooleanValue';\n}\n\nfunction isIntValue(value: ValueNode): value is IntValueNode {\n  return value.kind === 'IntValue';\n}\n\nfunction isFloatValue(value: ValueNode): value is FloatValueNode {\n  return value.kind === 'FloatValue';\n}\n\nfunction isVariable(value: ValueNode): value is VariableNode {\n  return value.kind === 'Variable';\n}\n\nfunction isObjectValue(value: ValueNode): value is ObjectValueNode {\n  return value.kind === 'ObjectValue';\n}\n\nfunction isListValue(value: ValueNode): value is ListValueNode {\n  return value.kind === 'ListValue';\n}\n\nfunction isEnumValue(value: ValueNode): value is EnumValueNode {\n  return value.kind === 'EnumValue';\n}\n\nfunction isNullValue(value: ValueNode): value is NullValueNode {\n  return value.kind === 'NullValue';\n}\n\nexport function valueToObjectRepresentation(\n  argObj: any,\n  name: NameNode,\n  value: ValueNode,\n  variables?: Object,\n) {\n  if (isIntValue(value) || isFloatValue(value)) {\n    argObj[name.value] = Number(value.value);\n  } else if (isBooleanValue(value) || isStringValue(value)) {\n    argObj[name.value] = value.value;\n  } else if (isObjectValue(value)) {\n    const nestedArgObj = {};\n    value.fields.map(obj =>\n      valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables),\n    );\n    argObj[name.value] = nestedArgObj;\n  } else if (isVariable(value)) {\n    const variableValue = (variables || ({} as any))[value.name.value];\n    argObj[name.value] = variableValue;\n  } else if (isListValue(value)) {\n    argObj[name.value] = value.values.map(listValue => {\n      const nestedArgArrayObj = {};\n      valueToObjectRepresentation(\n        nestedArgArrayObj,\n        name,\n        listValue,\n        variables,\n      );\n      return (nestedArgArrayObj as any)[name.value];\n    });\n  } else if (isEnumValue(value)) {\n    argObj[name.value] = (value as EnumValueNode).value;\n  } else if (isNullValue(value)) {\n    argObj[name.value] = null;\n  } else {\n    throw new InvariantError(\n      `The inline argument \"${name.value}\" of kind \"${(value as any).kind}\"` +\n        'is not supported. Use variables instead of inline arguments to ' +\n        'overcome this limitation.',\n    );\n  }\n}\n\nexport function storeKeyNameFromField(\n  field: FieldNode,\n  variables?: Object,\n): string {\n  let directivesObj: any = null;\n  if (field.directives) {\n    directivesObj = {};\n    field.directives.forEach(directive => {\n      directivesObj[directive.name.value] = {};\n\n      if (directive.arguments) {\n        directive.arguments.forEach(({ name, value }) =>\n          valueToObjectRepresentation(\n            directivesObj[directive.name.value],\n            name,\n            value,\n            variables,\n          ),\n        );\n      }\n    });\n  }\n\n  let argObj: any = null;\n  if (field.arguments && field.arguments.length) {\n    argObj = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n  }\n\n  return getStoreKeyName(field.name.value, argObj, directivesObj);\n}\n\nexport type Directives = {\n  [directiveName: string]: {\n    [argName: string]: any;\n  };\n};\n\nconst KNOWN_DIRECTIVES: string[] = [\n  'connection',\n  'include',\n  'skip',\n  'client',\n  'rest',\n  'export',\n];\n\nexport function getStoreKeyName(\n  fieldName: string,\n  args?: Record<string, any> | null,\n  directives?: Directives,\n): string {\n  if (\n    args &&\n    directives &&\n    directives['connection'] &&\n    directives['connection']['key']\n  ) {\n    if (\n      directives['connection']['filter'] &&\n      (directives['connection']['filter'] as string[]).length > 0\n    ) {\n      const filterKeys = directives['connection']['filter']\n        ? (directives['connection']['filter'] as string[])\n        : [];\n      filterKeys.sort();\n\n      const filteredArgs = {} as { [key: string]: any };\n      filterKeys.forEach(key => {\n        filteredArgs[key] = args[key];\n      });\n\n      return `${directives['connection']['key']}(${JSON.stringify(\n        filteredArgs,\n      )})`;\n    } else {\n      return directives['connection']['key'];\n    }\n  }\n\n  let completeFieldName: string = fieldName;\n\n  if (args) {\n    // We can't use `JSON.stringify` here since it's non-deterministic,\n    // and can lead to different store key names being created even though\n    // the `args` object used during creation has the same properties/values.\n    const stringifiedArgs: string = stringify(args);\n    completeFieldName += `(${stringifiedArgs})`;\n  }\n\n  if (directives) {\n    Object.keys(directives).forEach(key => {\n      if (KNOWN_DIRECTIVES.indexOf(key) !== -1) return;\n      if (directives[key] && Object.keys(directives[key]).length) {\n        completeFieldName += `@${key}(${JSON.stringify(directives[key])})`;\n      } else {\n        completeFieldName += `@${key}`;\n      }\n    });\n  }\n\n  return completeFieldName;\n}\n\nexport function argumentsObjectFromField(\n  field: FieldNode | DirectiveNode,\n  variables?: Record<string, any>,\n): Object | null {\n  if (field.arguments && field.arguments.length) {\n    const argObj: Object = {};\n    field.arguments.forEach(({ name, value }) =>\n      valueToObjectRepresentation(argObj, name, value, variables),\n    );\n    return argObj;\n  }\n  return null;\n}\n\nexport function resultKeyNameFromField(field: FieldNode): string {\n  return field.alias ? field.alias.value : field.name.value;\n}\n\nexport function getTypenameFromResult(\n  result: Record<string, any>,\n  selectionSet: SelectionSetNode,\n  fragmentMap?: FragmentMap,\n): string | undefined {\n  if (typeof result.__typename === 'string') {\n    return result.__typename;\n  }\n\n  for (const selection of selectionSet.selections) {\n    if (isField(selection)) {\n      if (selection.name.value === '__typename') {\n        return result[resultKeyNameFromField(selection)];\n      }\n    } else {\n      const typename = getTypenameFromResult(\n        result,\n        getFragmentFromSelection(selection, fragmentMap)!.selectionSet,\n        fragmentMap,\n      );\n      if (typeof typename === 'string') {\n        return typename;\n      }\n    }\n  }\n}\n\nexport function isField(selection: SelectionNode): selection is FieldNode {\n  return selection.kind === 'Field';\n}\n\nexport function isInlineFragment(\n  selection: SelectionNode,\n): selection is InlineFragmentNode {\n  return selection.kind === 'InlineFragment';\n}\n\nexport type VariableValue = (node: VariableNode) => any;\n"]},"metadata":{},"sourceType":"module"}