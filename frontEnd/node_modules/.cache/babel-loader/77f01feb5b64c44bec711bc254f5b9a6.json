{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { ApolloLink, execute } from \"../link/core/index.js\";\nimport { compact } from \"../utilities/index.js\";\nimport { version } from \"../version.js\";\nimport { HttpLink } from \"../link/http/index.js\";\nimport { QueryManager } from \"./QueryManager.js\";\nimport { LocalState } from \"./LocalState.js\";\nvar hasSuggestedDevtools = false;\nexport function mergeOptions(defaults, options) {\n  return compact(defaults, options, options.variables && {\n    variables: __assign(__assign({}, defaults.variables), options.variables)\n  });\n}\n\nvar ApolloClient = function () {\n  function ApolloClient(options) {\n    var _this = this;\n\n    this.defaultOptions = {};\n    this.resetStoreCallbacks = [];\n    this.clearStoreCallbacks = [];\n    var uri = options.uri,\n        credentials = options.credentials,\n        headers = options.headers,\n        cache = options.cache,\n        _a = options.ssrMode,\n        ssrMode = _a === void 0 ? false : _a,\n        _b = options.ssrForceFetchDelay,\n        ssrForceFetchDelay = _b === void 0 ? 0 : _b,\n        _c = options.connectToDevTools,\n        connectToDevTools = _c === void 0 ? typeof window === 'object' && !window.__APOLLO_CLIENT__ && process.env.NODE_ENV !== 'production' : _c,\n        _d = options.queryDeduplication,\n        queryDeduplication = _d === void 0 ? true : _d,\n        defaultOptions = options.defaultOptions,\n        _e = options.assumeImmutableResults,\n        assumeImmutableResults = _e === void 0 ? false : _e,\n        resolvers = options.resolvers,\n        typeDefs = options.typeDefs,\n        fragmentMatcher = options.fragmentMatcher,\n        clientAwarenessName = options.name,\n        clientAwarenessVersion = options.version;\n    var link = options.link;\n\n    if (!link) {\n      link = uri ? new HttpLink({\n        uri: uri,\n        credentials: credentials,\n        headers: headers\n      }) : ApolloLink.empty();\n    }\n\n    if (!cache) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(9) : new InvariantError(\"To initialize Apollo Client, you must specify a 'cache' property \" + \"in the options object. \\n\" + \"For more information, please visit: https://go.apollo.dev/c/docs\");\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(function () {\n        return _this.disableNetworkFetches = false;\n      }, ssrForceFetchDelay);\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    if (connectToDevTools && typeof window === 'object') {\n      window.__APOLLO_CLIENT__ = this;\n    }\n\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n\n      if (typeof window !== 'undefined' && window.document && window.top === window.self && !window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {\n        var nav = window.navigator;\n        var ua = nav && nav.userAgent;\n        var url = void 0;\n\n        if (typeof ua === \"string\") {\n          if (ua.indexOf(\"Chrome/\") > -1) {\n            url = \"https://chrome.google.com/webstore/detail/\" + \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n          } else if (ua.indexOf(\"Firefox/\") > -1) {\n            url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n          }\n        }\n\n        if (url) {\n          invariant.log(\"Download the Apollo DevTools for a better development \" + \"experience: \" + url);\n        }\n      }\n    }\n\n    this.version = version;\n    this.localState = new LocalState({\n      cache: cache,\n      client: this,\n      resolvers: resolvers,\n      fragmentMatcher: fragmentMatcher\n    });\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      queryDeduplication: queryDeduplication,\n      ssrMode: ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName,\n        version: clientAwarenessVersion\n      },\n      localState: this.localState,\n      assumeImmutableResults: assumeImmutableResults,\n      onBroadcast: connectToDevTools ? function () {\n        if (_this.devToolsHookCb) {\n          _this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: _this.queryManager.getQueryStore(),\n              mutations: _this.queryManager.mutationStore || {}\n            },\n            dataWithOptimisticResults: _this.cache.extract(true)\n          });\n        }\n      } : void 0\n    });\n  }\n\n  ApolloClient.prototype.stop = function () {\n    this.queryManager.stop();\n  };\n\n  ApolloClient.prototype.watchQuery = function (options) {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    if (this.disableNetworkFetches && (options.fetchPolicy === 'network-only' || options.fetchPolicy === 'cache-and-network')) {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n\n    return this.queryManager.watchQuery(options);\n  };\n\n  ApolloClient.prototype.query = function (options) {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(options.fetchPolicy !== 'cache-and-network', 10) : invariant(options.fetchPolicy !== 'cache-and-network', 'The cache-and-network fetchPolicy does not work with client.query, because ' + 'client.query can only return a single result. Please use client.watchQuery ' + 'to receive multiple results from the cache and the network, or consider ' + 'using a different fetchPolicy, such as cache-first or network-only.');\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = __assign(__assign({}, options), {\n        fetchPolicy: 'cache-first'\n      });\n    }\n\n    return this.queryManager.query(options);\n  };\n\n  ApolloClient.prototype.mutate = function (options) {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n\n    return this.queryManager.mutate(options);\n  };\n\n  ApolloClient.prototype.subscribe = function (options) {\n    return this.queryManager.startGraphQLSubscription(options);\n  };\n\n  ApolloClient.prototype.readQuery = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readQuery(options, optimistic);\n  };\n\n  ApolloClient.prototype.readFragment = function (options, optimistic) {\n    if (optimistic === void 0) {\n      optimistic = false;\n    }\n\n    return this.cache.readFragment(options, optimistic);\n  };\n\n  ApolloClient.prototype.writeQuery = function (options) {\n    this.cache.writeQuery(options);\n    this.queryManager.broadcastQueries();\n  };\n\n  ApolloClient.prototype.writeFragment = function (options) {\n    this.cache.writeFragment(options);\n    this.queryManager.broadcastQueries();\n  };\n\n  ApolloClient.prototype.__actionHookForDevTools = function (cb) {\n    this.devToolsHookCb = cb;\n  };\n\n  ApolloClient.prototype.__requestRaw = function (payload) {\n    return execute(this.link, payload);\n  };\n\n  ApolloClient.prototype.resetStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore();\n    }).then(function () {\n      return Promise.all(_this.resetStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    }).then(function () {\n      return _this.reFetchObservableQueries();\n    });\n  };\n\n  ApolloClient.prototype.clearStore = function () {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      return _this.queryManager.clearStore();\n    }).then(function () {\n      return Promise.all(_this.clearStoreCallbacks.map(function (fn) {\n        return fn();\n      }));\n    });\n  };\n\n  ApolloClient.prototype.onResetStore = function (cb) {\n    var _this = this;\n\n    this.resetStoreCallbacks.push(cb);\n    return function () {\n      _this.resetStoreCallbacks = _this.resetStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n\n  ApolloClient.prototype.onClearStore = function (cb) {\n    var _this = this;\n\n    this.clearStoreCallbacks.push(cb);\n    return function () {\n      _this.clearStoreCallbacks = _this.clearStoreCallbacks.filter(function (c) {\n        return c !== cb;\n      });\n    };\n  };\n\n  ApolloClient.prototype.reFetchObservableQueries = function (includeStandby) {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  };\n\n  ApolloClient.prototype.extract = function (optimistic) {\n    return this.cache.extract(optimistic);\n  };\n\n  ApolloClient.prototype.restore = function (serializedState) {\n    return this.cache.restore(serializedState);\n  };\n\n  ApolloClient.prototype.addResolvers = function (resolvers) {\n    this.localState.addResolvers(resolvers);\n  };\n\n  ApolloClient.prototype.setResolvers = function (resolvers) {\n    this.localState.setResolvers(resolvers);\n  };\n\n  ApolloClient.prototype.getResolvers = function () {\n    return this.localState.getResolvers();\n  };\n\n  ApolloClient.prototype.setLocalStateFragmentMatcher = function (fragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  };\n\n  ApolloClient.prototype.setLink = function (newLink) {\n    this.link = this.queryManager.link = newLink;\n  };\n\n  return ApolloClient;\n}();\n\nexport { ApolloClient };","map":{"version":3,"mappings":"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","names":["invariant","InvariantError","ApolloLink","execute","compact","version","HttpLink","QueryManager","LocalState","hasSuggestedDevtools","mergeOptions","defaults","options","variables","credentials","headers","cache","_a","ssrMode","_b","ssrForceFetchDelay","_c","connectToDevTools","window","__APOLLO_CLIENT__","process","env","NODE_ENV","_d","queryDeduplication","defaultOptions","_e","assumeImmutableResults","resolvers","typeDefs","fragmentMatcher","clientAwarenessName","clientAwarenessVersion","link","uri","empty","disableNetworkFetches","setTimeout","_this","watchQuery","bind","query","mutate","resetStore","reFetchObservableQueries","document","top","self","__APOLLO_DEVTOOLS_GLOBAL_HOOK__","nav","navigator","ua","userAgent","url","indexOf","log","localState","client","queryManager","clientAwareness","name","onBroadcast","devToolsHookCb","action","state","queries","getQueryStore","mutations","mutationStore","dataWithOptimisticResults","extract","ApolloClient","stop","fetchPolicy","startGraphQLSubscription","optimistic","readQuery","readFragment","writeQuery","broadcastQueries","writeFragment","cb","payload","Promise","resolve","then","clearStore","all","resetStoreCallbacks","map","clearStoreCallbacks","push","filter","includeStandby","serializedState","restore","addResolvers","setResolvers","getResolvers","setFragmentMatcher","newLink"],"sourceRoot":"","sources":["../../src/core/ApolloClient.ts"],"sourcesContent":["import { ExecutionResult, DocumentNode } from 'graphql';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport { ApolloLink, FetchResult, GraphQLRequest, execute } from '../link/core';\nimport { ApolloCache, DataProxy } from '../cache';\nimport { Observable, compact } from '../utilities';\nimport { version } from '../version';\nimport { HttpLink, UriFunction } from '../link/http';\n\nimport { QueryManager } from './QueryManager';\nimport { ObservableQuery } from './ObservableQuery';\n\nimport {\n  ApolloQueryResult,\n  OperationVariables,\n  Resolvers,\n} from './types';\n\nimport {\n  QueryOptions,\n  WatchQueryOptions,\n  MutationOptions,\n  SubscriptionOptions,\n  WatchQueryFetchPolicy,\n} from './watchQueryOptions';\n\nimport {\n  LocalState,\n  FragmentMatcher,\n} from './LocalState';\n\nexport interface DefaultOptions {\n  watchQuery?: Partial<WatchQueryOptions<any, any>>;\n  query?: Partial<QueryOptions<any, any>>;\n  mutate?: Partial<MutationOptions<any, any>>;\n}\n\nlet hasSuggestedDevtools = false;\n\nexport type ApolloClientOptions<TCacheShape> = {\n  uri?: string | UriFunction;\n  credentials?: string;\n  headers?: Record<string, string>;\n  link?: ApolloLink;\n  cache: ApolloCache<TCacheShape>;\n  ssrForceFetchDelay?: number;\n  ssrMode?: boolean;\n  connectToDevTools?: boolean;\n  queryDeduplication?: boolean;\n  defaultOptions?: DefaultOptions;\n  assumeImmutableResults?: boolean;\n  resolvers?: Resolvers | Resolvers[];\n  typeDefs?: string | string[] | DocumentNode | DocumentNode[];\n  fragmentMatcher?: FragmentMatcher;\n  name?: string;\n  version?: string;\n};\n\ntype OptionsUnion<TData, TVariables> =\n  | WatchQueryOptions<TVariables, TData>\n  | QueryOptions<TVariables, TData>\n  | MutationOptions<TData, TVariables>;\n\nexport function mergeOptions<\n  TOptions extends OptionsUnion<any, any>\n>(\n  defaults: Partial<TOptions>,\n  options: TOptions,\n): TOptions {\n  return compact(defaults, options, options.variables && {\n    variables: {\n      ...defaults.variables,\n      ...options.variables,\n    },\n  });\n}\n\n/**\n * This is the primary Apollo Client class. It is used to send GraphQL documents (i.e. queries\n * and mutations) to a GraphQL spec-compliant server over a {@link NetworkInterface} instance,\n * receive results from the server and cache the results in a store. It also delivers updates\n * to GraphQL queries through {@link Observable} instances.\n */\nexport class ApolloClient<TCacheShape> implements DataProxy {\n  public link: ApolloLink;\n  public cache: ApolloCache<TCacheShape>;\n  public disableNetworkFetches: boolean;\n  public version: string;\n  public queryDeduplication: boolean;\n  public defaultOptions: DefaultOptions = {};\n  public readonly typeDefs: ApolloClientOptions<TCacheShape>['typeDefs'];\n\n  private queryManager: QueryManager<TCacheShape>;\n  private devToolsHookCb: Function;\n  private resetStoreCallbacks: Array<() => Promise<any>> = [];\n  private clearStoreCallbacks: Array<() => Promise<any>> = [];\n  private localState: LocalState<TCacheShape>;\n\n  /**\n   * Constructs an instance of {@link ApolloClient}.\n   *\n   * @param uri The GraphQL endpoint that Apollo Client will connect to. If\n   *            `link` is configured, this option is ignored.\n   * @param link The {@link ApolloLink} over which GraphQL documents will be resolved into a response.\n   *\n   * @param cache The initial cache to use in the data store.\n   *\n   * @param ssrMode Determines whether this is being run in Server Side Rendering (SSR) mode.\n   *\n   * @param ssrForceFetchDelay Determines the time interval before we force fetch queries for a\n   * server side render.\n   *\n   * @param queryDeduplication If set to false, a query will still be sent to the server even if a query\n   * with identical parameters (query, variables, operationName) is already in flight.\n   *\n   * @param defaultOptions Used to set application wide defaults for the\n   *                       options supplied to `watchQuery`, `query`, or\n   *                       `mutate`.\n   *\n   * @param assumeImmutableResults When this option is true, the client will assume results\n   *                               read from the cache are never mutated by application code,\n   *                               which enables substantial performance optimizations. Passing\n   *                               `{ freezeResults: true }` to the `InMemoryCache` constructor\n   *                               can help enforce this immutability.\n   *\n   * @param name A custom name that can be used to identify this client, when\n   *             using Apollo client awareness features. E.g. \"iOS\".\n   *\n   * @param version A custom version that can be used to identify this client,\n   *                when using Apollo client awareness features. This is the\n   *                version of your client, which you may want to increment on\n   *                new builds. This is NOT the version of Apollo Client that\n   *                you are using.\n   */\n  constructor(options: ApolloClientOptions<TCacheShape>) {\n    const {\n      uri,\n      credentials,\n      headers,\n      cache,\n      ssrMode = false,\n      ssrForceFetchDelay = 0,\n      connectToDevTools =\n        // Expose the client instance as window.__APOLLO_CLIENT__ and call\n        // onBroadcast in queryManager.broadcastQueries to enable browser\n        // devtools, but disable them by default in production.\n        typeof window === 'object' &&\n        !(window as any).__APOLLO_CLIENT__ &&\n        process.env.NODE_ENV !== 'production',\n      queryDeduplication = true,\n      defaultOptions,\n      assumeImmutableResults = false,\n      resolvers,\n      typeDefs,\n      fragmentMatcher,\n      name: clientAwarenessName,\n      version: clientAwarenessVersion,\n    } = options;\n\n    let { link } = options;\n\n    if (!link) {\n      link = uri\n        ? new HttpLink({ uri, credentials, headers })\n        : ApolloLink.empty();\n    }\n\n    if (!cache) {\n      throw new InvariantError(\n        \"To initialize Apollo Client, you must specify a 'cache' property \" +\n        \"in the options object. \\n\" +\n        \"For more information, please visit: https://go.apollo.dev/c/docs\"\n      );\n    }\n\n    this.link = link;\n    this.cache = cache;\n    this.disableNetworkFetches = ssrMode || ssrForceFetchDelay > 0;\n    this.queryDeduplication = queryDeduplication;\n    this.defaultOptions = defaultOptions || {};\n    this.typeDefs = typeDefs;\n\n    if (ssrForceFetchDelay) {\n      setTimeout(\n        () => (this.disableNetworkFetches = false),\n        ssrForceFetchDelay,\n      );\n    }\n\n    this.watchQuery = this.watchQuery.bind(this);\n    this.query = this.query.bind(this);\n    this.mutate = this.mutate.bind(this);\n    this.resetStore = this.resetStore.bind(this);\n    this.reFetchObservableQueries = this.reFetchObservableQueries.bind(this);\n\n    if (connectToDevTools && typeof window === 'object') {\n      (window as any).__APOLLO_CLIENT__ = this;\n    }\n\n    /**\n     * Suggest installing the devtools for developers who don't have them\n     */\n    if (!hasSuggestedDevtools && process.env.NODE_ENV !== 'production') {\n      hasSuggestedDevtools = true;\n      if (\n        typeof window !== 'undefined' &&\n        window.document &&\n        window.top === window.self &&\n        !(window as any).__APOLLO_DEVTOOLS_GLOBAL_HOOK__\n      ) {\n        const nav = window.navigator;\n        const ua = nav && nav.userAgent;\n        let url: string | undefined;\n        if (typeof ua === \"string\") {\n          if (ua.indexOf(\"Chrome/\") > -1) {\n            url = \"https://chrome.google.com/webstore/detail/\" +\n              \"apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm\";\n          } else if (ua.indexOf(\"Firefox/\") > -1) {\n            url = \"https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/\";\n          }\n        }\n        if (url) {\n          invariant.log(\n            \"Download the Apollo DevTools for a better development \" +\n              \"experience: \" + url\n          );\n        }\n      }\n    }\n\n    this.version = version;\n\n    this.localState = new LocalState({\n      cache,\n      client: this,\n      resolvers,\n      fragmentMatcher,\n    });\n\n    this.queryManager = new QueryManager({\n      cache: this.cache,\n      link: this.link,\n      queryDeduplication,\n      ssrMode,\n      clientAwareness: {\n        name: clientAwarenessName!,\n        version: clientAwarenessVersion!,\n      },\n      localState: this.localState,\n      assumeImmutableResults,\n      onBroadcast: connectToDevTools ? () => {\n        if (this.devToolsHookCb) {\n          this.devToolsHookCb({\n            action: {},\n            state: {\n              queries: this.queryManager.getQueryStore(),\n              mutations: this.queryManager.mutationStore || {},\n            },\n            dataWithOptimisticResults: this.cache.extract(true),\n          });\n        }\n      } : void 0,\n    });\n  }\n\n  /**\n   * Call this method to terminate any active client processes, making it safe\n   * to dispose of this `ApolloClient` instance.\n   */\n  public stop() {\n    this.queryManager.stop();\n  }\n\n  /**\n   * This watches the cache store of the query according to the options specified and\n   * returns an {@link ObservableQuery}. We can subscribe to this {@link ObservableQuery} and\n   * receive updated results through a GraphQL observer when the cache store changes.\n   * <p /><p />\n   * Note that this method is not an implementation of GraphQL subscriptions. Rather,\n   * it uses Apollo's store in order to reactively deliver updates to your query results.\n   * <p /><p />\n   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's\n   * first and last name and this person has a particular object identifer, provided by\n   * dataIdFromObject. Later, a different query fetches that same person's\n   * first and last name and the first name has now changed. Then, any observers associated\n   * with the results of the first query will be updated with a new result object.\n   * <p /><p />\n   * Note that if the cache does not change, the subscriber will *not* be notified.\n   * <p /><p />\n   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for\n   * a description of store reactivity.\n   */\n  public watchQuery<T = any, TVariables = OperationVariables>(\n    options: WatchQueryOptions<TVariables, T>,\n  ): ObservableQuery<T, TVariables> {\n    if (this.defaultOptions.watchQuery) {\n      options = mergeOptions(this.defaultOptions.watchQuery, options);\n    }\n\n    // XXX Overwriting options is probably not the best way to do this long term...\n    if (\n      this.disableNetworkFetches &&\n      (options.fetchPolicy === 'network-only' ||\n        options.fetchPolicy === 'cache-and-network')\n    ) {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.watchQuery<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single query according to the options specified and\n   * returns a {@link Promise} which is either resolved with the resulting data\n   * or rejected with an error.\n   *\n   * @param options An object of type {@link QueryOptions} that allows us to\n   * describe how this query should be treated e.g. whether it should hit the\n   * server at all or just resolve from the cache, etc.\n   */\n  public query<T = any, TVariables = OperationVariables>(\n    options: QueryOptions<TVariables, T>,\n  ): Promise<ApolloQueryResult<T>> {\n    if (this.defaultOptions.query) {\n      options = mergeOptions(this.defaultOptions.query, options);\n    }\n\n    invariant(\n      (options.fetchPolicy as WatchQueryFetchPolicy) !== 'cache-and-network',\n      'The cache-and-network fetchPolicy does not work with client.query, because ' +\n      'client.query can only return a single result. Please use client.watchQuery ' +\n      'to receive multiple results from the cache and the network, or consider ' +\n      'using a different fetchPolicy, such as cache-first or network-only.'\n    );\n\n    if (this.disableNetworkFetches && options.fetchPolicy === 'network-only') {\n      options = { ...options, fetchPolicy: 'cache-first' };\n    }\n\n    return this.queryManager.query<T, TVariables>(options);\n  }\n\n  /**\n   * This resolves a single mutation according to the options specified and returns a\n   * {@link Promise} which is either resolved with the resulting data or rejected with an\n   * error.\n   *\n   * It takes options as an object with the following keys and values:\n   */\n  public mutate<T = any, TVariables = OperationVariables>(\n    options: MutationOptions<T, TVariables>,\n  ): Promise<FetchResult<T>> {\n    if (this.defaultOptions.mutate) {\n      options = mergeOptions(this.defaultOptions.mutate, options);\n    }\n    return this.queryManager.mutate<T>(options);\n  }\n\n  /**\n   * This subscribes to a graphql subscription according to the options specified and returns an\n   * {@link Observable} which either emits received data or an error.\n   */\n  public subscribe<T = any, TVariables = OperationVariables>(\n    options: SubscriptionOptions<TVariables, T>,\n  ): Observable<FetchResult<T>> {\n    return this.queryManager.startGraphQLSubscription<T>(options);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL query without making a network request. This method will start at\n   * the root query. To start at a specific id returned by `dataIdFromObject`\n   * use `readFragment`.\n   *\n   * @param optimistic Set to `true` to allow `readQuery` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readQuery<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Query<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readQuery<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Tries to read some data from the store in the shape of the provided\n   * GraphQL fragment without making a network request. This method will read a\n   * GraphQL fragment from any arbitrary id that is currently cached, unlike\n   * `readQuery` which will only read from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are reading. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   *\n   * @param optimistic Set to `true` to allow `readFragment` to return\n   * optimistic results. Is `false` by default.\n   */\n  public readFragment<T = any, TVariables = OperationVariables>(\n    options: DataProxy.Fragment<TVariables, T>,\n    optimistic: boolean = false,\n  ): T | null {\n    return this.cache.readFragment<T, TVariables>(options, optimistic);\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL query directly to\n   * the store. This method will start at the root query. To start at a\n   * specific id returned by `dataIdFromObject` then use `writeFragment`.\n   */\n  public writeQuery<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteQueryOptions<TData, TVariables>,\n  ): void {\n    this.cache.writeQuery<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n  }\n\n  /**\n   * Writes some data in the shape of the provided GraphQL fragment directly to\n   * the store. This method will write to a GraphQL fragment from any arbitrary\n   * id that is currently cached, unlike `writeQuery` which will only write\n   * from the root query.\n   *\n   * You must pass in a GraphQL document with a single fragment or a document\n   * with multiple fragments that represent what you are writing. If you pass\n   * in a document with multiple fragments then you must also specify a\n   * `fragmentName`.\n   */\n  public writeFragment<TData = any, TVariables = OperationVariables>(\n    options: DataProxy.WriteFragmentOptions<TData, TVariables>,\n  ): void {\n    this.cache.writeFragment<TData, TVariables>(options);\n    this.queryManager.broadcastQueries();\n  }\n\n  public __actionHookForDevTools(cb: () => any) {\n    this.devToolsHookCb = cb;\n  }\n\n  public __requestRaw(payload: GraphQLRequest): Observable<ExecutionResult> {\n    return execute(this.link, payload);\n  }\n\n  /**\n   * Resets your entire store by clearing out your cache and then re-executing\n   * all of your active queries. This makes it so that you may guarantee that\n   * there is no data left in your store from a time before you called this\n   * method.\n   *\n   * `resetStore()` is useful when your user just logged out. Youâ€™ve removed the\n   * user session, and you now want to make sure that any references to data you\n   * might have fetched while the user session was active is gone.\n   *\n   * It is important to remember that `resetStore()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   */\n  public resetStore(): Promise<ApolloQueryResult<any>[] | null> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.resetStoreCallbacks.map(fn => fn())))\n      .then(() => this.reFetchObservableQueries());\n  }\n\n  /**\n   * Remove all data from the store. Unlike `resetStore`, `clearStore` will\n   * not refetch any active queries.\n   */\n  public clearStore(): Promise<any[]> {\n    return Promise.resolve()\n      .then(() => this.queryManager.clearStore())\n      .then(() => Promise.all(this.clearStoreCallbacks.map(fn => fn())));\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * reset. `onResetStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onResetStore(cb: () => Promise<any>): () => void {\n    this.resetStoreCallbacks.push(cb);\n    return () => {\n      this.resetStoreCallbacks = this.resetStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Allows callbacks to be registered that are executed when the store is\n   * cleared. `onClearStore` returns an unsubscribe function that can be used\n   * to remove registered callbacks.\n   */\n  public onClearStore(cb: () => Promise<any>): () => void {\n    this.clearStoreCallbacks.push(cb);\n    return () => {\n      this.clearStoreCallbacks = this.clearStoreCallbacks.filter(c => c !== cb);\n    };\n  }\n\n  /**\n   * Refetches all of your active queries.\n   *\n   * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage\n   *\n   * It is important to remember that `reFetchObservableQueries()` *will* refetch any active\n   * queries. This means that any components that might be mounted will execute\n   * their queries again using your network interface. If you do not want to\n   * re-execute any queries then you should make sure to stop watching any\n   * active queries.\n   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.\n   */\n  public reFetchObservableQueries(\n    includeStandby?: boolean,\n  ): Promise<ApolloQueryResult<any>[]> {\n    return this.queryManager.reFetchObservableQueries(includeStandby);\n  }\n\n  /**\n   * Exposes the cache's complete state, in a serializable format for later restoration.\n   */\n  public extract(optimistic?: boolean): TCacheShape {\n    return this.cache.extract(optimistic);\n  }\n\n  /**\n   * Replaces existing state in the cache (if any) with the values expressed by\n   * `serializedState`.\n   *\n   * Called when hydrating a cache (server side rendering, or offline storage),\n   * and also (potentially) during hot reloads.\n   */\n  public restore(serializedState: TCacheShape): ApolloCache<TCacheShape> {\n    return this.cache.restore(serializedState);\n  }\n\n  /**\n   * Add additional local resolvers.\n   */\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.addResolvers(resolvers);\n  }\n\n  /**\n   * Set (override existing) local resolvers.\n   */\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.localState.setResolvers(resolvers);\n  }\n\n  /**\n   * Get all registered local resolvers.\n   */\n  public getResolvers() {\n    return this.localState.getResolvers();\n  }\n\n  /**\n   * Set a custom local state fragment matcher.\n   */\n  public setLocalStateFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.localState.setFragmentMatcher(fragmentMatcher);\n  }\n\n  /**\n   * Define a new ApolloLink (or link chain) that Apollo Client will use.\n   */\n  public setLink(newLink: ApolloLink) {\n    this.link = this.queryManager.link = newLink;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}