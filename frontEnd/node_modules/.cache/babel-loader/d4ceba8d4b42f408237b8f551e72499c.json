{"ast":null,"code":"import { NetworkStatus } from \"./networkStatus.js\";\nimport { compact } from \"../utilities/index.js\";\nimport { invariant } from 'ts-invariant';\n\nvar Reobserver = function () {\n  function Reobserver(observer, options, fetch, shouldFetch) {\n    this.observer = observer;\n    this.options = options;\n    this.fetch = fetch;\n    this.shouldFetch = shouldFetch;\n  }\n\n  Reobserver.prototype.reobserve = function (newOptions, newNetworkStatus) {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      this.updatePolling();\n    }\n\n    var concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n    return (this.concast = concast).promise;\n  };\n\n  Reobserver.prototype.updateOptions = function (newOptions) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  };\n\n  Reobserver.prototype.stop = function () {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  };\n\n  Reobserver.prototype.updatePolling = function () {\n    var _this = this;\n\n    var _a = this,\n        pollingInfo = _a.pollingInfo,\n        pollInterval = _a.options.pollInterval;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n\n      return;\n    }\n\n    if (pollingInfo && pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    process.env.NODE_ENV === \"production\" ? invariant(pollInterval, 20) : invariant(pollInterval, 'Attempted to start a polling query without a polling interval.');\n\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    var info = pollingInfo || (this.pollingInfo = {});\n    info.interval = pollInterval;\n\n    var maybeFetch = function () {\n      if (_this.pollingInfo) {\n        if (_this.shouldFetch && _this.shouldFetch()) {\n          _this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: _this.options.fetchPolicy || \"cache-first\"\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      }\n\n      ;\n    };\n\n    var poll = function () {\n      var info = _this.pollingInfo;\n\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  };\n\n  return Reobserver;\n}();\n\nexport { Reobserver };","map":{"version":3,"mappings":"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","names":["NetworkStatus","compact","invariant","observer","options","fetch","shouldFetch","Reobserver","newOptions","newNetworkStatus","updateOptions","updatePolling","concast","removeObserver","addObserver","promise","Object","assign","pollingInfo","clearTimeout","timeout","pollInterval","interval","process","NODE_ENV","info","maybeFetch","_this","reobserve","fetchPolicy","nextFetchPolicy","poll","then","setTimeout"],"sourceRoot":"","sources":["../../src/core/Reobserver.ts"],"sourcesContent":["import { WatchQueryOptions } from './watchQueryOptions';\nimport { NetworkStatus } from './networkStatus';\nimport { ApolloQueryResult } from './types';\nimport { Observer, Concast, compact } from '../utilities';\nimport { invariant } from 'ts-invariant';\n\n// Given that QueryManager#fetchQueryObservable returns only a single\n// query's worth of results, other code must be responsible for repeatedly\n// calling fetchQueryObservable, while ensuring that the ObservableQuery\n// consuming those results remains subscribed to the concatenation of all\n// the observables returned by fetchQueryObservable. That responsibility\n// falls to this Reobserver class. As a bonus, the Reobserver class is\n// perfectly poised to handle polling logic, since polling is essentially\n// repeated reobservation. In principle, this code could have remained in\n// the ObservableQuery class, but I felt it would be easier to explain and\n// understand reobservation if it was confined to a separate class.\nexport class Reobserver<TData, TVars> {\n  constructor(\n    private observer: Observer<ApolloQueryResult<TData>>,\n    private options: WatchQueryOptions<TVars, TData>,\n    // Almost certainly just a wrapper function around\n    // QueryManager#fetchQueryObservable, but this small dose of\n    // indirection means the Reobserver doesn't have to know/assume\n    // anything about the QueryManager class.\n    private fetch: (\n      options: WatchQueryOptions<TVars, TData>,\n      newNetworkStatus?: NetworkStatus,\n    ) => Concast<ApolloQueryResult<TData>>,\n    // If we're polling, there may be times when we should avoid fetching,\n    // such as when the query is already in flight, or polling has been\n    // completely disabled for server-side rendering. Passing false for\n    // this parameter disables polling completely, and passing a boolean\n    // function allows determining fetch safety dynamically.\n    private shouldFetch: false | (() => boolean),\n  ) {}\n\n  private concast?: Concast<ApolloQueryResult<TData>>;\n\n  public reobserve(\n    newOptions?: Partial<WatchQueryOptions<TVars, TData>>,\n    newNetworkStatus?: NetworkStatus,\n  ): Promise<ApolloQueryResult<TData>> {\n    if (newOptions) {\n      this.updateOptions(newOptions);\n    } else {\n      // When we call this.updateOptions(newOptions) in the branch above,\n      // it takes care of calling this.updatePolling(). In this branch, we\n      // still need to update polling, even if there were no newOptions.\n      this.updatePolling();\n    }\n\n    const concast = this.fetch(this.options, newNetworkStatus);\n\n    if (this.concast) {\n      // We use the {add,remove}Observer methods directly to avoid\n      // wrapping observer with an unnecessary SubscriptionObserver\n      // object, in part so that we can remove it here without triggering\n      // any unsubscriptions, because we just want to ignore the old\n      // observable, not prematurely shut it down, since other consumers\n      // may be awaiting this.concast.promise.\n      this.concast.removeObserver(this.observer, true);\n    }\n\n    concast.addObserver(this.observer);\n\n    return (this.concast = concast).promise;\n  }\n\n  public updateOptions(newOptions: Partial<WatchQueryOptions<TVars, TData>>) {\n    Object.assign(this.options, compact(newOptions));\n    this.updatePolling();\n    return this;\n  }\n\n  public stop() {\n    if (this.concast) {\n      this.concast.removeObserver(this.observer);\n      delete this.concast;\n    }\n\n    if (this.pollingInfo) {\n      clearTimeout(this.pollingInfo.timeout);\n      this.options.pollInterval = 0;\n      this.updatePolling();\n    }\n  }\n\n  private pollingInfo?: {\n    interval: number;\n    timeout: ReturnType<typeof setTimeout>;\n  };\n\n  // Turns polling on or off based on this.options.pollInterval.\n  private updatePolling() {\n    const {\n      pollingInfo,\n      options: {\n        pollInterval,\n      },\n    } = this;\n\n    if (!pollInterval) {\n      if (pollingInfo) {\n        clearTimeout(pollingInfo.timeout);\n        delete this.pollingInfo;\n      }\n      return;\n    }\n\n    if (pollingInfo &&\n        pollingInfo.interval === pollInterval) {\n      return;\n    }\n\n    invariant(\n      pollInterval,\n      'Attempted to start a polling query without a polling interval.',\n    );\n\n    // Go no further if polling is disabled.\n    if (this.shouldFetch === false) {\n      return;\n    }\n\n    const info = pollingInfo || (\n      this.pollingInfo = {} as Reobserver<TData, TVars>[\"pollingInfo\"]\n    )!;\n\n    info.interval = pollInterval;\n\n    const maybeFetch = () => {\n      if (this.pollingInfo) {\n        if (this.shouldFetch && this.shouldFetch()) {\n          this.reobserve({\n            fetchPolicy: \"network-only\",\n            nextFetchPolicy: this.options.fetchPolicy || \"cache-first\",\n          }, NetworkStatus.poll).then(poll, poll);\n        } else {\n          poll();\n        }\n      };\n    };\n\n    const poll = () => {\n      const info = this.pollingInfo;\n      if (info) {\n        clearTimeout(info.timeout);\n        info.timeout = setTimeout(maybeFetch, info.interval);\n      }\n    };\n\n    poll();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}